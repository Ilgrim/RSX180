;**********************************************************************;
;                                                                      ;
;   Program to create a RSX180 task image file from a CP/M .COM file   ;
;   by adding a task header. Copyright (C) 2016-2019, Hector Peraza.   ;
;                                                                      ;
;   This program is free software; you can redistribute it and/or      ;
;   modify it under the terms of the GNU General Public License as     ;
;   published by the Free Software Foundation; either version 2 of     ;
;   the License, or (at your option) any later version.                ;
;                                                                      ;
;   This program is distributed in the hope that it will be useful,    ;
;   but WITHOUT ANY WARRANTY; without even the implied warranty of     ;
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      ;
;   GNU General Public License for more details.                       ;
;                                                                      ;
;   You should have received a copy of the GNU General Public License  ;
;   along with this program; if not, write to the Free Software        ;
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.          ;
;                                                                      ;
;**********************************************************************;

;----------------------------------------------------------------------;
;                                                                      ;
;   Usage:                                                             ;
;     MKT [outfile]=inpfile[/INC=nnnn][/TASK=xxxxxx][/[NO|-]PRIV]      ;
;          [/PAR=xxxxxx][/PRI=nnn][/ASG=SY0:1-4,TI:5:6...][/ID=xxxxxx] ;
;                                                                      ;
;----------------------------------------------------------------------;

; TODO:
; - checksum?
; - starting register values?
; - add support for segments:
;   * num segments (1 byte)
;   * then:
;     - segment type (1 byte): data, code, absolute, reloc, root,
;       overlay, r/o, etc.
;     - file offset (4 bytes) [or relative block number (2 bytes)]
;     - load address (2 bytes)
;     - length (2 bytes)
;     A typical task image file will contain just one segment, a task
;     with overlays will have several.

	.z80

	include	SYSFN.INC
	include	FCB.INC
	include	GCML.INC
	include	TCB.INC
	include	THDR.INC
	include	FCSLIB.INC
	include	ERRORS.INC

	extrn	GCML,RCML,UCASE,PERROR,TTFLSH,PUTCH,PUTSTR,HLDEC
	extrn	PDN,PFN,FOPEN,FCREAT,FSIZE,FREAD,FWRITE,FCLOSE

CR	equ	0Dh
LF	equ	0Ah
ESC	equ	1Bh
EOF	equ	1Ah

LUNCML	equ	1
LUNSRC	equ	2
LUNDST	equ	3

;-----------------------------------------------------------------------

	cseg

MAIN:	ld	sp,stack

	call	INIT

m1:	call	TTFLSH
	ld	iy,GDAT
	call	GCML		; get command line tail
	jr	c,m2		; jump on error

	ld	(lnptr),hl	; save pointer to command tail
	call	PROCESS		; process the command
	jr	m1		; loop for more

m2:	cp	E.EOF		; end of file?
	jr	z,m3		; exit normally if yes

	call	CMLERR		; else display error
	ld	iy,GDAT
	call	RCML		; reset command state
	jr	m1		; and loop
	
m3:	call	TTFLSH
	ld	hl,EX.SUC
	SC	.EXIT		; exit

;-----------------------------------------------------------------------

; Perform initializations

INIT:	ld	hl,0
	ld	de,TSKTCB
	SC	.GTSK		; get task info
	ld	hl,TSKTCB+T.NAME
	call	ckdots		; skip initial 3 dots if present
	push	hl
	ld	de,(GDAT+G.PRM)	; set prompt to our task name
	inc	de
	inc	de
	ld	bc,3
	ldir
	pop	hl
	ld	de,errpfx+2	; set task name in error message prefix
	ld	bc,3
	ldir
	ret

ckdots:	ld	b,3
	push	hl
ckd1:	ld	a,(hl)
	cp	'.'
	jr	nz,ckd2
	inc	hl
	djnz	ckd1
	inc	sp
	inc	sp
	ret
ckd2:	pop	hl
	ret

;-----------------------------------------------------------------------

; Print error message in the form 'MKT -- message'.

CMDERR:	ld	hl,snerr
ERROR:	push	hl
	ld	hl,errpfx
	call	PUTSTR
	pop	hl
	call	PUTSTR
	call	ATLINE
	ld	c,CR
	call	PUTCH
	scf
	ret

snerr:	db	'Command syntax error',0

; Like the above, but displays a standard error message.

SYSERR:	push	af
	ld	hl,errpfx
	call	PUTSTR
	pop	af
	call	PERROR
	call	ATLINE
	ld	c,CR
	call	PUTCH
	scf
	ret

; Display CML or system error message

CMLERR:	or	a
	jp	m,SYSERR
	ld	hl,ERROR
	push	hl
	cp	GE.OK
	ld	hl,msgok
	ret	z
	cp	GE.SN
	ld	hl,snerr
	ret	z
	cp	GE.LEN
	ld	hl,msglen
	ret	z
	cp	GE.NLV
	ld	hl,msgnlv
	ret	z
	pop	hl
	jp	SYSERR

msgok:	db	'No error',0
msglen:	db	'Line too long in command file',0
msgnlv:	db	'Command nesting level too deep',0

; Display line number of indirect file where error happened

ATLINE:	ld	hl,GDAT+G.ST
	bit	GS.FIL,(hl)
	ret	z
	ld	hl,(GDAT+G.LN)
	ld	a,h
	or	l
	ret	z
	push	hl
	ld	hl,atln
	call	PUTSTR
	pop	hl
	xor	a
	call	HLDEC
	ret

atln:	db	' at line ',0

;-----------------------------------------------------------------------

; Get command name (6 chars max) from input line into cmdnam.

GETCMD:	ld	de,(lnptr)
	ld	hl,cmdnam
	ld	b,6
	call	GETNB
	call	GETNAM
	ld	(lnptr),de
	ret

; Get task name (6 chars max, padded with spaces) from input line
; into cmdnam.

GETTN:	call	GETCMD
	inc	b
	dec	b
	ret	z
sfill:	ld	(hl),' '
	inc	hl
	djnz	sfill
	ret

; Get a name (up to B bytes in length) into HL buffer.

GETNAM:	call	GETFS
	jr	z,gn3
	call	UCASE
	ld	(hl),a
	inc	hl
	inc	de
	djnz	GETNAM
gn2:	call	GETFS
	jr	z,gn3
	inc	de
	jr	gn2
gn3:	ld	(hl),0
	ret

; Get next non-blank char. Returns Z flag set on end of line.

GETNB:	ld	a,(de)
	call	ISEOL
	ret	z
	cp	' '
	ret	nz
	inc	de
	jr	GETNB

; Get next char. Returns Z on end of line or if char is a delimiter.

GETFS:	ld	a,(de)
	call	ISEOL
	ret	z
	cp	' '
	jr	c,gf1
	ret	z
	cp	'='
	ret	z
	cp	','
	ret	z
	cp	'/'
	ret	z
	cp	':'
	ret	z
	cp	'-'
	ret	z
	ret
gf1:	xor	a
	ret

; Return Z if char in A is end-of-line.

ISEOL:	or	a
	ret	z
	cp	CR
	ret	z
	cp	LF
	ret	z
	cp	ESC
	ret	z
	cp	EOF
	ret

; Read a decimal number from input line into HL
; Returns CY if the number contains invalid chars or if overflow.

GETDEC:	ld	de,(lnptr)
	call	GETNB
	ld	hl,0
newdig:	call	GETFS
	jr	z,endnum	; note no CY
	sub	'0'
	jr	c,endnum	; note CY
	cp	10
	ccf
	jr	c,endnum	; note CY
	call	adddig		; note CY on overflow
	inc	de
	jr	nc,newdig
endnum:	ld	(lnptr),de
	ret

adddig:	ld	c,l
	ld	b,h
	add	hl,hl
	ret	c
	add	hl,hl
	ret	c
	add	hl,bc
	ret	c
	add	hl,hl
	ret	c
	ld	c,a
	ld	b,0
	add	hl,bc
	ret

; Search for the command (cmdnam) in the command table (HL = cmdtab).
; Returns A=0FFh if not found, or 0 if cmdnam contains an empty string.
; Otherwise returns the command position in the table (1-based).

fndcmd:	ld	de,cmdnam
	ld	a,(de)
	or	a
	ret	z
	ld	b,0		; number of matches
	ld	c,1		; keyword index
	ld	a,c
	push	af
fcmd0:	ld	de,cmdnam
fcmd1:	ld	a,(de)
	or	a
	jr	z,fcmd3
	cp	(hl)
	jr	nz,fcmd2
	inc	hl
	inc	de
	jr	fcmd1
fcmd3:	inc	b
	pop	af
	ld	a,(hl)		;;
	or	a		;;
	ld	a,c
	ret	z		;;
	push	af
fcmd2:	ld	a,(hl)
	inc	hl
	or	a
	jr	nz,fcmd2
	inc	c
	ld	a,(hl)
	or	a
	jr	nz,fcmd0
	pop	af
	dec	b
	ret	z
	ld	a,0FFh
	ret

;-----------------------------------------------------------------------

; Parse the command line

PARSE:	ld	hl,(lnptr)
	ld	ix,OFNAME
	call	PFN		; parse output file name
	jp	c,CMDERR
	ld	a,(hl)		; see where PFN stopped
	cp	'='
	jp	nz,CMDERR	; must be equal sign
	inc	hl
	ld	ix,IFNAME
	call	PFN		; parse input file name
	jp	c,CMDERR
	ld	(lnptr),hl
par1:	ld	de,(lnptr)
	call	GETNB		; get next non-blank char
	call	ISEOL		; end of line?
	ret	z		; return if yes
	cp	'/'		; switch?
	jp	nz,CMDERR	; error if not
	inc	de
	call	chkneg		; check for negated switch
	ld	(lnptr),de
	call	GETCMD		; get switch name
	ld	hl,cmdnam
	ld	a,(hl)
	cp	' '		; empty?
	jp	z,CMDERR	; error if yes
	ld	hl,SWTAB
	call	FNDCMD		; find name in table
	or	a
	jp	z,CMDERR
	cp	0FFh
	jp	z,CMDERR	; error if not found
	ld	c,a		; get switch value into C
	dec	c
	jr	z,swprv		; set privileged flag
	call	chkeq		; argument required for all others
	jp	nz,CMDERR
	ld	a,(negsw)
	or	a		; only PRIV switch can be negated
	jp	nz,CMDERR
	dec	c
	jp	z,swasg		; assign LUNs
	dec	c
	jr	z,swid		; set task ID
	dec	c
	jr	z,swinc		; set memory increment
	dec	c
	jr	z,swpri		; set priority
	dec	c
	jr	z,swtask	; set task name
	dec	c
	jr	z,swpar		; set partition name
	dec	c
	jr	z,swcpu		; set CPU type
	jp	CMDERR

swprv:	ld	a,(negsw)
	or	a
	ld	a,1
	jr	z,stpri
	xor	a
stpri:	ld	(THDR+TH.PRV),a	; set/clear privileged flag
	jp	par1

swid:	call	GETTN
	ld	hl,cmdnam
	ld	a,(hl)
	cp	' '
	jp	z,CMDERR
	ld	de,THDR+TH.VID
	ld	bc,6
	ldir			; set task version ID
	jp	par1

swinc:	call	GETDEC
	jp	c,CMDERR
	ld	(THDR+TH.INC),hl ; set memory increment
	jp	par1

swpri:	call	GETDEC
	jp	c,CMDERR
	ld	a,h
	or	a
	jp	nz,CMDERR
	ld	a,l
	ld	(THDR+TH.PRI),a	; set priority
	jp	par1

swtask:	call	GETTN
	ld	hl,cmdnam
	ld	a,(hl)
	cp	' '
	jp	z,CMDERR
	ld	de,THDR+TH.NAME
	ld	bc,6
	ldir			; set task name
	jp	par1

swpar:	call	GETTN
	ld	hl,cmdnam
	ld	a,(hl)
	cp	' '
	jp	z,CMDERR
	ld	de,THDR+TH.PAR
	ld	bc,6
	ldir			; set task partition name
	jp	par1

swcpu:	call	GETDEC
	jp	c,CMDERR
	ld	a,h
	or	a
	jp	nz,CMDERR
	ld	a,l
	cp	2+1
	jp	nc,CMDERR
	ld	(THDR+TH.CPU),a	; set CPU type
	jp	par1

swasg:	ld	hl,THDR+TH.LUNT
	ld	(hl),0
	ld	e,l
	ld	d,h
	inc	de
	ld	bc,16*4
	ldir			; clear any previous LUN assignment
	ld	hl,(lnptr)
asg1:	call	PDN		; get device name
	jp	c,CMDERR	; error if invalid
	ld	(dev),de	; else save it
	ld	a,c
	ld	(dev+2),a
asg2:	ld	(lnptr),hl
	call	getlun		; get LUN
	jp	c,CMDERR
	ld	b,a		;  into B
	ld	de,(dev)	; get device name into DE
	ld	a,(dev+2)
	ld	c,a		; and unit number into C
	call	setlun		; set LUN
asg4:	ld	hl,(lnptr)
	ld	a,(hl)		; get following char
	inc	hl
	cp	','		; comma means start of new device assignment
	jr	z,asg1
	cp	':'		; colon is LUN separator for same device
	jr	z,asg2
	cp	'-'		; dash is LUN range for same device
	jp	nz,par1		; else exit
	ld	(lnptr),hl
	push	bc
	call	getlun		; get target LUN
	pop	bc
	jp	c,CMDERR
	ld	l,a
	ld	de,(dev)	; get device name into DE
	ld	a,(dev+2)
	ld	c,a		; and unit number into C
asg3:	inc	b
	ld	a,l
	cp	b
	jr	c,asg4
	push	hl
	call	setlun		; set LUN
	pop	hl
	jr	asg3

getlun:	call	GETDEC		; get LUN
	ret	c
	ld	a,h		; ensure is in range 1..16
	or	a
	scf
	ret	nz
	ld	a,l
	or	a
	scf
	ret	z
	dec	a
	cp	16
	ccf
	ret

setlun:	ld	a,b
	rlca
	rlca
	ld	hl,THDR+TH.LUNT
	call	addhla		; index into LUN table
	ld	(hl),e		; assign device
	inc	hl
	ld	(hl),d
	inc	hl
	ld	(hl),c
	inc	hl
	ld	(hl),0
	ret

addhla:	add	a,l
	ld	l,a
	ret	nc
	inc	h
	ret

chkneg:	xor	a
	ld	(negsw),a
	ld	a,(de)
	call	UCASE
	cp	'-'
	jr	z,swneg
	cp	'N'
	ret	nz
	inc	de
	ld	a,(de)
	call	UCASE
	cp	'O'
	dec	de
	ret	nz
	inc	de
swneg:	inc	de
	ld	a,0FFh
	ld	(negsw),a
	ret

chkeq:	ld	hl,(lnptr)
	ld	a,(hl)
	cp	'='
	ret	nz
	inc	hl
	ld	(lnptr),hl
	ret

SWTAB:	db	'PRIV',0
	db	'ASG',0
	db	'ID',0
	db	'INC',0
	db	'PRI',0
	db	'TASK',0
	db	'PAR',0
	db	'CPU',0
	db	0

;----------------------------------------------------------------------

; Process the command

PROCESS:
	; initialize header

	ld	hl,THDR
	ld	(hl),0
	ld	e,l
	ld	d,h
	inc	de
	ld	bc,THSZ-1
	ldir			; clear everything

	ld	hl,tskid
	ld	de,THDR+TH.HDR
	ld	bc,6
	ldir			; set magic string

	ld	hl,1*256+2
	ld	(THDR+TH.VER),hl ; set version number

	ld	a,50
	ld	(THDR+TH.PRI),a ; set default priority

	ld	hl,defasg
	ld	de,THDR+TH.LUNT
	ld	bc,asgln
	ldir			; set default LUN assignment

	ld	hl,THDR+TH.NAME
	ld	(hl),' '
	ld	e,l
	ld	d,h
	inc	de
	ld	bc,6-1
	ldir			; clear task name

	ld	hl,THDR+TH.VID
	ld	(hl),' '
	ld	e,l
	ld	d,h
	inc	de
	ld	bc,6-1
	ldir			; clear task version ID

	ld	hl,defpar
	ld	de,THDR+TH.PAR
	ld	bc,6
	ldir			; set default partition name

	; parse the command line and setup header fields

	call	PARSE
	ret	c		; return on error

	; open input file

	ld	ix,IFBK
	call	FOPEN
	jp	c,SYSERR

	ld	hl,clsinp
	push	hl

	ld	ix,IFBK
	call	FSIZE		; use file size as end address
	jp	c,SYSERR
	ld	a,h
	or	l
	ld	hl,ebig		; ensure file is not too big
	jp	nz,ERROR
	ld	a,d
	or	e
	ld	hl,enull	; or too small
	jp	z,ERROR

	ld	hl,100h
	ld	(THDR+TH.STRT),hl ; set start address
	ld	(THDR+TH.EPT),hl  ; and entry point

	add	hl,de
	ld	(THDR+TH.END),hl  ; set end address
	ld	hl,ebig
	jp	c,ERROR

	; create output file

	ld	a,(OFNAME+F.ATTR)
	and	FN.NAME OR FN.EXT
	jr	nz,proc1

	ld	hl,IFNAME+F.NAME
	ld	de,OFNAME+F.NAME
	ld	bc,9
	ldir			; if not output name given use input.TSK
	ld	hl,tskext
	ld	de,OFNAME+F.EXT
	ld	bc,3
	ldir

	ld	a,(OFNAME+F.ATTR)
	or	FN.NAME OR FN.EXT
	ld	(OFNAME+F.ATTR),a

proc1:	ld	hl,(THDR+TH.END)
	ld	de,THSZ
	add	hl,de
	ld	de,511
	add	hl,de
	sra	h
	ld	e,h
	ld	d,0		; blocks to allocate for contiguous file

	ld	ix,OFBK
	ld	c,1		; contiguous file flag
	call	FCREAT
	jp	c,SYSERR

	ld	hl,clsout
	push	hl

	ld	de,THDR+TH.NAME
	ld	a,(de)
	cp	' '
	jr	nz,proc2
	ld	hl,OFNAME+F.NAME
	ld	bc,6		; if no task name given, use first 6 chars
	ldir			;  from output file name

proc2:	; write header

	ld	ix,OFBK
	ld	de,THDR
	ld	bc,THSZ
	call	FWRITE
	jp	c,SYSERR

	; now append the program code from input file

cpbin:	ld	ix,IFBK
	ld	de,THDR		; recycle header as I/O buffer
	ld	bc,2048
	call	FREAD
	jr	nc,cp1
	cp	E.EOF
	ret	z
	jp	SYSERR
cp1:	ld	a,b
	or	c
	ret	z
	ld	ix,OFBK
	ld	de,THDR
	call	FWRITE
	jp	c,SYSERR
	jr	cpbin

clsinp:	ld	ix,IFBK
	call	FCLOSE
	ret

clsout:	ld	ix,OFBK
	call	FCLOSE
	jp	c,SYSERR
	ret

ebig:	db	'Input file too big',0
enull:	db	'Input file empty',0

tskext:	db	'TSK'
tskid:	db	'TSK180'
defpar:	db	'GEN   '

; Default LUN assignment table

defasg:	db	'SY',0,0	; 1
	db	'SY',0,0
	db	'SY',0,0
	db	'SY',0,0
	db	'TI',0,0	; 5
	db	'CL',0,0	; 6

	IF	0

	db	'SY',0,0
	db	'SY',0,0	; 8
	db	'SY',0,0
	db	'SY',0,0	; 10
	db	'SY',0,0
	db	'SY',0,0
	db	'OV',0,0
	db	'OV',0,0
	db	'OV',0,0
	db	'OV',0,0	; 16

	ENDIF

asgln	equ	$ - defasg

;-----------------------------------------------------------------------

	dseg

TSKTCB:	ds	TCBSZ

errpfx:	db	CR,LF,'MKT -- ',0

GDAT:	GCML$	CMDBUF,80,'MKT',LUNCML,2

CMDBUF:	ds	82

lnptr:	ds	2
cmdnam:	ds	6
negsw:	ds	1
dev:	ds	3

IFBK:	FSR$	IFNAME,<1 SHL FM.RD>,LUNSRC,9
OFBK:	FSR$	OFNAME,<1 SHL FM.WR>,LUNDST,9

IFNAME:	ds	FINFSZ		; FDB for input file name
OFNAME:	ds	FINFSZ		; FDB for output file name

THDR:	ds	2048		; used for both header and file I/O,
				;  must be larger than THSZ

	ds	128
stack	equ	$

	end	MAIN
