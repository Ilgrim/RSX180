;**********************************************************************;
;                                                                      ;
;   This file is part of RSX180, a multi-tasking OS for the Z180.      ;
;   Copyright (C) 1985-2019, Hector Peraza.                            ;
;                                                                      ;
;   This program is free software; you can redistribute it and/or      ;
;   modify it under the terms of the GNU General Public License as     ;
;   published by the Free Software Foundation; either version 2 of     ;
;   the License, or (at your option) any later version.                ;
;                                                                      ;
;   This program is distributed in the hope that it will be useful,    ;
;   but WITHOUT ANY WARRANTY; without even the implied warranty of     ;
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      ;
;   GNU General Public License for more details.                       ;
;                                                                      ;
;   You should have received a copy of the GNU General Public License  ;
;   along with this program; if not, write to the Free Software        ;
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.          ;
;                                                                      ;
;**********************************************************************;

	NAME	('CLKQ')
	TITLE	'RSX180 Clock queue'

;----------------------------------------------------------------------;
;                                                                      ;
;	Clock Queue routines                                           ;
;                                                                      ;
;----------------------------------------------------------------------;

	.Z80

	include	CLKQ.INC
	include	TCB.INC
	include	AST.INC
	include	ERRORS.INC

	cseg

	public	CLQADD		; add packet to clock queue
	public	CHKCLQ		; check clock queue, dispatch expiring events
	public	CLNCLQ		; clock queue cleanup

	extrn	TICCNT,$CLKQ,QAST,$ALLOC,$FREE,SETFLG,TRQST2
	extrn	$TLIST,FTCB

;-----------------------------------------------------------------------

; Add an item to the clock queue.

; Input:
;   IY   = TCB of associated task
;   HLDE = absolute time in ticks
;   B    = request type
;   C    = event flag number

CLQADD:	push	iy
	push	hl
	push	de
	push	bc
	ld	bc,CLQSZ	; BC = packet size
	call	$ALLOC		; allocate queue item
	push	hl
	pop	ix		; IX = new item address
	pop	bc
	pop	de
	pop	hl
	pop	iy
	ret	c		; on error return
	ld	(ix+C.TIME),e	; set absolute time
	ld	(ix+C.TIME+1),d
	ld	(ix+C.TIME+2),l
	ld	(ix+C.TIME+3),h
	ld	(ix+C.EFN),c	; set event flag number
	ld	(ix+C.TYPE),b	; set request type
	push	iy
	pop	hl
	ld	(ix+C.TCB),l	; set TCB address
	ld	(ix+C.TCB+1),h	;  and continue below

; Enter packet into the clock queue. The queue is sorted by increasing
; absolute time.
;
; Input:
;   IX = address of item to add

LNKCLQ:	ld	iy,$CLKQ	; get addr of list head into IY
lclk1:	ld	e,(iy)		; get next ptr into DE
	ld	d,(iy+1)
	ld	a,d
	or	e		; end of the list?
	jr	z,lclk2		; jump if yes
	push	de
	push	ix
	pop	hl		; HL = addr of new item
	ld	bc,C.TIME+3
	add	hl,bc
	ex	de,hl		; DE = addr of timestamp of new item (MSB)
	add	hl,bc		; HL = addr of timestamp of queued item (MSB)
	di
	call	CMPTIM		; compare timestamps
	ei
	pop	de
	jr	c,lclk2		; jump if queued packet has higher time
	push	de		; else go to next item in list
	pop	iy
	jr	lclk1		; and try again

; we arrive here with:
;   IY = prev item in clock queue
;   DE = current item in clock queue
;   IX = new item to insert

lclk2:	push	ix
	pop	hl
	ld	(iy),l		; set prev pointer in list
	ld	(iy+1),h
	ld	(ix),e		; set next pointer in new item
	ld	(ix+1),d
	xor	a		; return success
	ret

;-----------------------------------------------------------------------

; Check the clock queue, remove expiring and/or expired items and
; perform the requested action.

CHKCLQ:	ld	iy,$CLKQ
cclk1:	ld	c,(iy)		; get ptr to queue item into BC
	ld	b,(iy+1)
	ld	a,b		; end of list
	or	c
	ret	z		; return if yes
	ld	hl,C.TIME+3
	add	hl,bc		; HL = addr of time field of packet (MSB)
	ld	de,TICCNT+3	; DE = addr of absolute system time (MSB)
	push	bc		; push address of packet
	di
	call	CMPTIM		; compare with current system time
	ei
	jr	c,cclk3		; return if not expired (current time is lower)
	pop	ix		; IX = packet
	push	iy
	call	ACTION		; execute desired action
	pop	iy
	push	iy
	call	FRECQP		; unlink and free the packet
	pop	iy
;;	push	ix	-- only if packet was left in queue...
;;	pop	iy
	jr	cclk1		; check next packet

cclk3:	pop	bc
	ret

; Compare timestamp @DE with @HL. Returns CY if time @HL > @DE.

CMPTIM:	ld	b,4
cmpt1:	ld	a,(de)
	cp	(hl)
	ret	nz
	dec	hl
	dec	de
	djnz	cmpt1
	ret

; Execute the specified action

ACTION:	ld	a,(ix+C.TYPE)
	cp	CT.MKT
	jr	z,CMKT
	cp	CT.RUN
	jr	z,CRUN
	ret

; Mark time request: set event flag and (possibly) execute AST

CMKT:	ld	c,(ix+C.TCB)
	ld	b,(ix+C.TCB+1)
	ld	e,(ix+C.EFN)
	push	ix
	push	bc
	call	SETFLG
	pop	bc
	pop	ix
	;ret	c
	ld	hl,T.AST
	add	hl,bc
	ld	a,(hl)
	inc	hl
	or	(hl)		; task has ASTs enabled?
	ret	z		; return if not
	ld	hl,T.SAST
	add	hl,bc
	ld	a,(hl)
	and	AST.CK		; task wants mark time ASTs?
	ret	z		; return if not
	push	ix
	push	bc
	ld	bc,AHSZ
	call	$ALLOC
	pop	bc
	pop	ix
	;ret	c		; can't send AST to task (not enough pool
				; memory), what to do:
				; - ignore and continue? (but task will
				;   keep waiting forever)
				; - abort task?
				; - do not remove this packet, maybe next
				;   time we'll get lucky? [note: if we free
				;   the packet before queuing the AST, we
				;   will have enough pool free]
	push	bc
	pop	iy		; IY = task's TCB
	push	hl
	ex	(sp),ix		; IX = AST packet
	ld	(ix+A.SIZ),0
	ld	(ix+A.TYP),AST.CK
	call	QAST		; queue AST to task
	pop	ix
	ret

; Run task at specified time: request task

CRUN:	ld	iy,TMPTDB
	ld	e,'C'		; set terminal device to CO:
	ld	d,'O'
	ld	c,0
	ld	(iy+TD.CON),e
	ld	(iy+TD.CON+1),d
	ld	(iy+TD.CON+2),c
	xor	a
	ld	(iy+TD.ATTR),a	; clear TA.MCR bit
	ld	(iy+TD.USR),a	; TODO: set UIC to 1,1?
	ld	(iy+TD.GRP),a
	ld	(iy+TD.CMD),a	; no command line
	ld	(iy+TD.CMD+1),a
	ld	(iy+TD.CML),a
	ld	(iy+TD.CML+1),a
	ld	c,(ix+C.TCB)
	ld	b,(ix+C.TCB+1)
  IF 1
	push	ix
	push	iy
	ld	iy,$TLIST
	ld	de,T.TCBL
	call	FTCB		; just in case - ensure TCB is valid
	pop	iy		; IX = TCB, IY = TDB
	call	nc,TRQST2	; request task
	pop	ix
	ret
  ELSE
	push	bc
	ex	(sp),ix		; IX = TCB, IY = TDB
	call	TRQST2		; request task
	pop	ix
	ret
  ENDIF

; Unlink and free the clock queue item

FRECQP:	ld	a,(ix)
	ld	(iy),a
	ld	a,(ix+1)
	ld	(iy+1),a
	push	ix
	pop	hl
	ld	de,CLQSZ
	push	ix
	call	$FREE
	pop	ix
	ret

;-----------------------------------------------------------------------

; Remove from the clock queue all items that belong to the specified
; task. Called to cancel a specific Time Mark Request, during task
; cleanup on exit (mark time requests), and/or upon removing a task
; from STD (scheduled run requests).

; Input:
;   IX = TCB address
;   C  = request type
;   B  = optional event flag number (0FFh to remove all requests)

CLNCLQ:	ld	iy,$CLKQ
	push	ix
	pop	de		; DE = TCB address
ccln1:	ld	l,(iy)
	ld	h,(iy+1)
	ld	a,h
	or	l
	ret	z
	push	hl
	pop	ix
	ld	a,(ix+C.TYPE)	; check request type
	cp	c
	jr	nz,ccln3
	ld	a,b
	inc	a		; check event flag number
	jr	z,ccln2		; skip if 0FFh
	ld	a,(ix+C.EFN)
	cp	b
	jr	nz,ccln3
ccln2:	ld	a,(ix+C.TCB)	; check TCB
	cp	e
	jr	nz,ccln3
	ld	a,(ix+C.TCB+1)
	cp	d
	jr	nz,ccln3
	push	de
	push	bc
	call	FRECQP		; unlink and free the packet
	pop	bc
	pop	de
	jr	ccln1
ccln3:	push	ix
	pop	iy
	jr	ccln1

;-----------------------------------------------------------------------

	dseg

TMPTDB:	ds	TDBSZ

	end
