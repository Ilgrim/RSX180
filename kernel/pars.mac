;**********************************************************************;
;                                                                      ;
;   This file is part of RSX180, a multi-tasking OS for the Z180.      ;
;   Copyright (C) 1985-2019, Hector Peraza.                            ;
;                                                                      ;
;   This program is free software; you can redistribute it and/or      ;
;   modify it under the terms of the GNU General Public License as     ;
;   published by the Free Software Foundation; either version 2 of     ;
;   the License, or (at your option) any later version.                ;
;                                                                      ;
;   This program is distributed in the hope that it will be useful,    ;
;   but WITHOUT ANY WARRANTY; without even the implied warranty of     ;
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      ;
;   GNU General Public License for more details.                       ;
;                                                                      ;
;   You should have received a copy of the GNU General Public License  ;
;   along with this program; if not, write to the Free Software        ;
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.          ;
;                                                                      ;
;**********************************************************************;

	NAME	('KMEM')
	TITLE	'RSX180 Partition Management'

;-----------------------------------------------------------------------;
;                                                                       ;
;	Partition Management routines.                                  ;
;                                                                       ;
;-----------------------------------------------------------------------;

	.z80

	include	PCB.INC
	include	ERRORS.INC

	public	NEWPAR		; create main partition control block
	public	NEWSUB		; create subpatition control block
	public	$FNPAR		; find main partition
	public	MALLOC		; allocate subpartition
	public	MEXTND		; resize subpartition
	public	MFREE		; free subpartition
	public	MAVAIL		; get amount of free memory in partition

	extrn	$ALLOC,$FREE,CLRMEM

	extrn	$PLIST

	cseg

;-----------------------------------------------------------------------

; Create main partition.
; Called with B = partition base, C = partition size, DE = partition name.
; Returns IX = new PCB
;
; Note: does not check for duplicate names.

NEWPAR:	push	de
	push	bc
	ld	bc,PCBSZ
	call	$ALLOC		; allocate PCB
	pop	bc
	pop	de
	ret	c
	push	hl
	pop	ix
	ld	(ix+P.BASE),b	; set partition base
	ld	(ix+P.SIZE),c	; set partition size
	ld	(ix+P.MAIN),l
	ld	(ix+P.MAIN+1),h
	push	bc
	ld	bc,P.NAME
	add	hl,bc
	ex	de,hl
	ld	bc,6
	ldir			; set partition name
	pop	bc
	xor	a
	ld	(ix+P.SUB),a	; subpartition list is initially empty
	ld	(ix+P.SUB+1),a
	ld	(ix+P.ATTR),a
	ld	(ix+P.STAT),a
	ld	(ix+P.TCB),a
	ld	(ix+P.TCB+1),a
	ld	hl,$PLIST	; keep list sorted by address
np1:	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	a,d
	or	e		; end of list?
	jr	z,np2		; branch if yes, link at end
	push	hl
	ld	hl,P.BASE
	add	hl,de
	ld	a,b		; get base of new PCB
	cp	(hl)		; compare with base of this PCB
	pop	hl
	jr	c,np2		; branch if this base > new base, insert here
	ex	de,hl
	jr	np1		; else loop
np2:	ld	(ix+P.LNK),e	; set next link on new PCB
	ld	(ix+P.LNK+1),d
	push	ix
	pop	de
	ld	(hl),d		; set next link on prev PCB
	dec	hl
	ld	(hl),e
	ret

; Create subpartition.
; Called with IY = pointer to main PCB, E = partition size.
; Returns IX = pointer to new sub PCB

NEWSUB:	ld	bc,PCBSZ
	push	de
	call	$ALLOC		; allocate new sub PCB
	pop	de
	ret	c		; not enough pool
	push	hl
	pop	ix		; IX = new sub PCB
	ld	bc,P.NAME
	add	hl,bc
	ld	b,6
ma1:	ld	(hl),' '	; clear name field
	inc	hl
	djnz	ma1
	push	iy
	pop	hl
	ld	(ix+P.MAIN),l	; set pointer to main PCB
	ld	(ix+P.MAIN+1),h
	xor	a
	ld	(ix+P.SUB),a
	ld	(ix+P.SUB+1),a
	ld	(ix+P.ATTR),a
	ld	(ix+P.STAT),a
	ld	(ix+P.TCB),a
	ld	(ix+P.TCB+1),a
	set	PA.SUB,(ix+P.ATTR)
	ld	(ix+P.SIZE),e	; set size
	ret			; return success

;-----------------------------------------------------------------------

; Allocate task memory.
; IX = valid subpartition PCB
; E = num pages
; Returns CY on error (no space)

MALLOC:	ld	l,(ix+P.MAIN)	; get pointer to main partition
	ld	h,(ix+P.MAIN+1)
	push	hl
	pop	iy		;  into IY
	push	ix
	call	FNDGAP		; find gap, sets PRVLNK
	pop	ix
	ret	c
	set	PS.BSY,(ix+P.STAT)
	ld	(ix+P.BASE),d	; set subpartition base
	; continue below

; Link PCB. Called with PRVLNK = addr of 'next' field in prev PCB,
; IX = PCB to link, HL = next PCB.

LNKPCB:	ld	(ix+P.LNK),l	; keep subpartition list sorted by address
	ld	(ix+P.LNK+1),h
	push	ix
	pop	bc
	ld	hl,(PRVLNK)	; update P.SUB if prev is main,
	ld	(hl),c		;  or P.LNK if prev is sub
	inc	hl
	ld	(hl),b
	xor	a		; return success and PCB in IX
	ret

; Find free gap in partition. Called with IY = main PCB, E = size.
; Returns HL = IX = next PCB, PRVLNK = addr of 'next' link to update,
; D = base of gap. Preserves E (size) and IY (main PCB).

FNDGAP:	bit	PA.SYS,(iy+P.ATTR)
	ld	a,E.NOMEM	; TODO: E.UPAR
	scf
	ret	z		; return error if not system-controlled

	; system-controlled partition

	push	iy
	pop	hl
	ld	bc,P.SUB
	add	hl,bc
	ld	(PRVLNK),hl	; save address of field to update

	ld	a,(iy+P.BASE)
	ld	d,a		; remember base

	ld	l,(iy+P.SUB)
	ld	h,(iy+P.SUB+1)

	push	hl
	pop	ix		; IX = sub PCB
	ld	a,h
	or	l
	jr	z,fg3		; branch if no subpartitions

	ld	bc,P.LNK

fg1:	; loop over subpartitions

	ld	a,(ix+P.BASE)	; note: 2 bytes for Z280
	sub	d		; get size of preceding gap
	cp	e		; gap big enough?
	ret	nc		; return if yes

	add	hl,bc
	ld	(PRVLNK),hl	; save address of field to update

	ld	a,(ix+P.BASE)
	add	a,(ix+P.SIZE)
	ld	d,a		; new base is after this segment

	ld	l,(ix+P.LNK)	; get pointer to next subpartition in list
	ld	h,(ix+P.LNK+1)
	push	hl
	pop	ix
	ld	a,h
	or	l
	jr	nz,fg1		; loop

	; end of subpartition list

	ld	a,(iy+P.BASE)
	add	a,(iy+P.SIZE)
	sub	d		; get size of last gap
	jr	fg4

fg3:	; no subpartitions yet

	ld	a,(iy+P.SIZE)	; gap size is main partition size
fg4:	cp	e		; big enough?
	ret	nc		; return if yes
	ld	a,E.NOMEM
	ret			; else return error (note CY set)

;-----------------------------------------------------------------------

; Free task memory. IX = valid subpartition PCB.
; Does NOT free the PCB.

MFREE:	ld	l,(ix+P.MAIN)	; get pointer to main partition
	ld	h,(ix+P.MAIN+1)
	ld	a,h
	or	l		; safety check (should not happen)
	scf			; TODO: call the system crash rotuine
	ret	z
	push	hl
	pop	iy
	; continue below	; TODO: call the system crash routine
				;  if UNLPCB fails (CY set)?

; Unlink subpartition PCB. Called with IY = main PCB, IX = sub PCB.
; Sets PRVLNK. Returns DE = IX = sub PCB.

UNLPCB:	push	ix
	pop	de		; DE = sub PCB

	push	iy
	pop	hl		; HL = main PCB

	ld	bc,P.SUB

mf1:	add	hl,bc
	ld	(PRVLNK),hl	; save address of field to update

	ld	a,(hl)		; get next subpartition in list
	inc	hl
	ld	h,(hl)
	ld	l,a
	or	h
	scf
	ret	z		; should not happen

	ld	bc,P.LNK
	call	CPHLDE		; same sub PCB?
	jr	nz,mf1		; loop if not

	ld	hl,(PRVLNK)
	ld	a,(ix+P.LNK)
	ld	(hl),a		; unlink
	inc	hl
	ld	a,(ix+P.LNK+1)
	ld	(hl),a
	ret			; note CY clear

cphlde:	ld	a,d
	cp	h
	ret	nz
	ld	a,e
	cp	l
	ret

;-----------------------------------------------------------------------

; Extend task memory. E = num pages, IX = valid subpartition PCB.
; Returns IX = modified PCB.

MEXTND:	ld	l,(ix+P.MAIN)
	ld	h,(ix+P.MAIN+1)
	push	hl
	pop	iy
	bit	PA.SYS,(iy+P.ATTR)
	scf
	ld	a,E.NOMEM
	ret	z		; error, not a system-controlled partition
	ld	l,(ix+P.LNK)	; get next subpartition in list
	ld	h,(ix+P.LNK+1)
	ld	a,h
	or	l
	jr	nz,mx1		; branch if not the last in list

	; at end of subpartition list

	ld	d,(ix+P.BASE)
	ld	a,(iy+P.SIZE)
	sub	d		; get size of last gap
	jr	mx2

mx1:	; in middle of subpartition list

	ld	bc,P.BASE
	add	hl,bc
	ld	a,(hl)
	sub	(ix+P.BASE)	; compute max space avail to this subpartition
mx2:	cp	e		; large enough?
	jr	c,mx3		; branch if not
	ld	(ix+P.SIZE),e	; else simply adjust size
	xor	a		;  and return
	ret

mx3:	; no more space in this subpartition, try allocating a new one

	push	de
	call	UNLPCB		; unlink PCB
	pop	de
	ret	c		; should not happen
	ld	hl,(PRVLNK)
	push	hl		; save PRVLNK
	push	ix
	call	FNDGAP		; find new gap
	pop	ix
	jr	c,mx4		; branch if none found

	ld	(ix+P.BASE),d	; set new base
	ld	(ix+P.SIZE),e	;  and size
	pop	bc		; discard old PRVLNK
	call	LNKPCB		; link into new place
	ret
	
mx4:	pop	hl
	ld	(PRVLNK),hl	; restore PRVLNK
	ld	l,(ix+P.LNK)	; use old next pointer
	ld	h,(ix+P.LNK+1)
	call	LNKPCB		; restore PCB
	ld	a,E.NOMEM
	scf
	ret

;-----------------------------------------------------------------------

; Calculate available memory. IY = main partition PCB.
; Returns number of pages in HL.

MAVAIL:	ld	l,(iy+P.SIZE)	; get main partition size
	ld	h,0
	bit	PA.SYS,(iy+P.ATTR)
	ret	z		; return if not system-controlled

	; system-controlled partition

	ld	e,(iy+P.SUB)
	ld	d,(iy+P.SUB+1)
mav1:	ld	a,d
	or	e
	ret	z		; return if no (more) subpartitions

	push	de
	pop	ix		; IX = sub PCB
	ld	e,(ix+P.SIZE)
	ld	d,0
	or	a
	sbc	hl,de		; subtract from main partition size

	ld	e,(ix+P.LNK)	; get pointer to next subpartition in list
	ld	d,(ix+P.LNK+1)
	jr	mav1

;-----------------------------------------------------------------------

; Find main partition. BC = name. Returns HL = PCB.

$FNPAR:	ld	hl,($PLIST)
fp1:	ld	a,h
	or	l
	scf
	ld	a,E.PNF		; main partition not found
	ret	z
	push	hl
	push	de
	push	bc
	ld	de,P.NAME
	add	hl,de
	ld	e,6
fp2:	ld	a,(bc)
	sub	(hl)
	jr	nz,fp3
	inc	hl
	inc	bc
	dec	e
	jr	nz,fp2
fp3:	pop	bc
	pop	de
	pop	hl
	ret	z		; found
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	jr	fp1

;-----------------------------------------------------------------------

  IF 0

	include	TCB.INC

	extrn	GETSIZ,QLDR,$LKTCB

; Queue TCB to the main partition's wait list.
; Called with IX = TCB address.

QPAR:	ld	l,(ix+T.PCB)	; get pointer to subpartition
	ld	h,(ix+T.PCB+1)
	ld	de,P.MAIN
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a		; HL = pointer to main partition
	ld	de,P.WAIT
	add	hl,de
	push	hl		; point to P.WAIT field
	pop	iy
	ld	bc,T.LNK	; use utility link field
	jp	$LKTCB		; link TCB to wait list
	
;-----------------------------------------------------------------------

; Scan the wait list of each main partition in the system partition list.
; For each task (of the highest priority class) competing for memory,
; determine if there is enough space in the partition. If yes, assign
; the task to the partition and queue a request to the loader to load
; the task.

PSCAN:	ld	iy,$PLIST
ps1:	ld	c,(iy)		; get pointer to partition
	ld	b,(iy+1)
	ld	a,b
	or	c		; end of list?
	ret	z		; return if yes
	push	bc
	push	bc
	pop	iy
	call	WSCAN		; else check this partition's wait list
	pop	iy
	jr	ps1		; loop to process next

WSCAN:	bit	PA.SYS,(iy+P.ATTR) ; system-controlled partition?
	jr	nz,ps2		   ; branch if yes

	bit	PS.BSY,(iy+P.STAT) ; partition busy?
	ret	nz		   ; return if not

	ld	l,(iy+P.WAIT)	; get pointer to 1st TCB in wait list
	ld	h,(iy+P.WAIT+1)
	ld	l,a
	or	h		; any tasks waiting on this partition?
	ret	nz		; return if not

	push	hl
	pop	ix		; IX = 1st TCB

	call	GETSIZ		; compute task size
;;	jr	c,...		; abort task: will not fit in memory
;;				; (should have been validated by INS or VMR,
;;				;  will cause a LDR 'Load Error')

;;	ld	a,(iy+P.SIZE)
;;	cp	e
;;	jr	c,...		; abort task: will not fit in partition
;;				; (should have been validated by INS or VMR,
;;				;  will cause a LDR 'Load Error')

	set	PS.BSY,(iy+P.STAT)

	push	iy
	pop	bc
	ld	(ix+T.PCB),c	; assign partition to the task
	ld	(ix+T.PCB+1),b
	push	ix
	pop	bc
	ld	(iy+P.TCB),c	; assign task to the partition
	ld	(iy+P.TCB+1),b

	ld	a,(ix+T.LNK)
	ld	(iy+P.WAIT),a	; remove TCB from the partition wait list
	ld	a,(ix+T.LNK+1)
	ld	(iy+P.WAIT+1),a

	call	QLDR		; queue task to loader
				;  (T2.OUT and T2.CKP are already set)
	ret

ps2:	ld	de,P.WAIT
	add	iy,de		; IY = addr of 'prev' field for unlink op
ps3:	ld	c,(iy)		; get pointer to 1st TCB in wait list
	ld	b,(iy+1)
	ld	a,b
	or	c		; any tasks waiting on this partition?
	ret	nz		; return if not

	push	bc
	pop	ix		; IX = TCB address

	ld	a,(ix+T.PRI)
	ld	(TPRI),a	; remember first task's priority

ps4:	ld	e,(ix+T.PCB)
	ld	d,(ix+T.PCB+1)
	push	de
	ex	(sp),ix		; push TCB, pop sub PCB
	push	iy
	ld	e,(ix+P.SIZE)
	call	MALLOC		; try to allocate memory for task
	pop	iy
	pop	ix		; pop TCB address
	jr	c,ps5		; skip if not enough memory

	ld	a,(ix+T.LNK)
	ld	(iy),a		; unlink TCB from partition wait list
	ld	a,(ix+T.LNK+1)
	ld	(iy+1),a

	push	iy
	call	QLDR		; queue task to loader (T2.OUT and T2.CKP
	pop	iy		;  are already set)
	jr	ps3		; loop to process next task,
				;  resetting priority class

ps5:	ld	c,(ix+T.LNK)	; get next TCB in wait list
	ld	b,(ix+T.LNK+1)
	ld	a,b
	or	c		; end of list?
	ret	z		; return if yes

	push	ix
	pop	iy		; get addr 'prev' field into IY
;	ld	de,T.LNK	; we *know* T.LNK is 0
;	add	iy,de		;
;;	lea	iy,(ix+T.LNK)	; Z280

	push	bc
	pop	ix

	ld	a,(TPRI)
	cp	(ix+T.PRI)	; same priority class?
	jr	z,ps4		; loop to process task if yes
	ret			; else we're done

  ENDIF

;-----------------------------------------------------------------------

	dseg

PRVLNK:	ds	2
TPRI:	ds	1

	end
