;**********************************************************************;
;                                                                      ;
;   This file is part of RSX180, a multi-tasking OS for the Z180.      ;
;   Copyright (C) 1985-2019, Hector Peraza.                            ;
;                                                                      ;
;   This program is free software; you can redistribute it and/or      ;
;   modify it under the terms of the GNU General Public License as     ;
;   published by the Free Software Foundation; either version 2 of     ;
;   the License, or (at your option) any later version.                ;
;                                                                      ;
;   This program is distributed in the hope that it will be useful,    ;
;   but WITHOUT ANY WARRANTY; without even the implied warranty of     ;
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      ;
;   GNU General Public License for more details.                       ;
;                                                                      ;
;   You should have received a copy of the GNU General Public License  ;
;   along with this program; if not, write to the Free Software        ;
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.          ;
;                                                                      ;
;**********************************************************************;

	NAME	('FLAGS')
	TITLE	'RSX180 Flag Management'

;----------------------------------------------------------------------;
;                                                                      ;
;	Flag handling routines                                         ;
;                                                                      ;
;----------------------------------------------------------------------;

	.Z80

	include	TCB.INC
	include	ERRORS.INC

	public	CLRFLG		; clear flag
	public	SETFLG		; set flag
	public	CHKFLG		; check flag
	public	CKWMSK		; check flag wait mask
	public	FLWAIT		; wait for flag

	extrn	TWAIT,TCONT,$FNTCB

	cseg

;-----------------------------------------------------------------------

; Clear flag.

; Input:
;   BC = TCB of flag owner task
;   E  = flag number
; Returns:
;   A = 0 on success, else error code with CY set

CLRFLG:	ld	a,e
	rrca
	rrca
	rrca			; upper 5 bits are byte index in flag array
	and	1Fh
	cp	4
	jr	nc,clrf2
	ld	hl,T.FLGS
	add	hl,bc		; point to flags table in TCB
	ld	c,a		; get flag byte offset into BC
	ld	b,0
	add	hl,bc		; index into table
	ld	a,e
	and	07h		; low 3 bits are bit number in flag array
	ld	b,a
	inc	b		; so mask starts as 0FEh
	ld	a,7Fh
clrf1:	rlca			; get the zero-bit into position
	djnz	clrf1
	and	(hl)		; clear the flag
	ld	(hl),a
	xor	a
	ei
	ret
clrf2:	ld	a,E.BADFL
	scf
	ret

;-----------------------------------------------------------------------

; Set flag and wakeup the corresponding task.

; Input:
;   BC = TCB address of flag owner
;   E  = flag number
; Returns:
;   CY flag on error

; Notes:
; - We need to ensure that task still exists (and is active) by calling
;   $FNTCB, since this routine can be called by privileged tasks such
;   as SYSFCP to set another task's flags.

SETFLG:	push	de
	push	bc
	call	$FNTCB
	pop	bc
	pop	de
	ret	c
	ld	a,e
	rrca
	rrca
	rrca			; upper 5 bits are byte number in flag array
	and	1Fh
	cp	4
	jr	nc,setf2
	push	bc
	ld	hl,T.FLGS
	add	hl,bc		; point to flags table in TCB
	ld	c,a		; get flag byte offset into BC
	ld	b,0
	add	hl,bc		; index into table
	ld	a,e
	and	07h		; low 3 bits are bit number in flag array
	ld	b,a
	inc	b		; so mask starts as 01h
	ld	a,80h
setf1:	rlca			; get bit into position
	djnz	setf1
	or	(hl)		; set flag
	ld	(hl),a
	pop	bc		; task FCB back in BC
	push	bc
	call	CKWMSK		; check wait mask
	pop	bc
	call	nz,TCONT	; if flag set, resume task
	xor	a
	ret
setf2:	ld	a,E.BADFL
	scf
	ret

;-----------------------------------------------------------------------

; Check wait mask to see if a flag the task waiting for is set.

; Input:
;   BC = TCB
; Returns:
;   Z if none of the flags the task is waiting for is set,
;   NZ otherwise.

CKWMSK:	ld	hl,T.FLGS
	add	hl,bc
	ex	de,hl		; DE = flag table
	ld	hl,T.WAIT
	add	hl,bc		; HL = wait mask
	ld	b,4
ckm1:	ld	a,(de)
	and	(hl)		; target flag set?
	ret	nz		; return NZ if yes
	inc	hl
	inc	de
	djnz	ckm1
	ret			; else return Z

;-----------------------------------------------------------------------

; Check flag. Called typically from current task context.

; Input:
;   BC = TCB
;   E  = flag number
; Returns:
;   Z flag set and A=0 if flag not set, else NZ and A<>0
;   CY set on error and error code in A.
;   Flag number still in E.

CHKFLG:	ld	a,e
	rrca
	rrca
	rrca			; upper 5 bits are byte number in flag array
	and	1Fh
	cp	4
	jr	nc,ckf2
	ld	hl,T.FLGS
	add	hl,bc
	ld	c,a		; get flag byte offset into BC
	ld	b,0
	add	hl,bc		; index into table
	ld	a,e
	and	07h		; low 3 bits are bit number in flag array
	ld	b,a
	inc	b		; so mask starts as 01h
	ld	a,80h
ckf1:	rlca
	djnz	ckf1
	and	(hl)
	ret
ckf2:	ld	a,E.BADFL
	scf
	ret

;-----------------------------------------------------------------------

; Wait for flag.

; Input:
;   BC = TCB
;   E  = flag number

; Return immediately if in the meantime the flag has been already set.

FLWAIT:	ld	a,e
	rrca
	rrca
	rrca			; upper 5 bits are byte number in flag array
	and	1Fh
	cp	4
	jr	nc,flw3
	push	bc		; push TCB
	ld	hl,T.WAIT
	add	hl,bc
	ld	b,4
	push	hl		; push address T.WAIT
flw1:	ld	(hl),0		; clear wait mask
	inc	hl
	djnz	flw1
	pop	hl		; pop T.WAIT
	ld	c,a		; flag byte offset in BC
	ld	b,0
	add	hl,bc		; index into wait mask table
	ld	a,e
	and	07h		; low 3 bits are bit number in flag array
	ld	b,a
	inc	b		; so mask starts as 01h
	ld	a,80h
flw2:	rlca
	djnz	flw2
	or	(hl)
	ld	(hl),a		; set bit in wait mask
	pop	bc		; TCB back in BC
	push	bc
	call	CKWMSK		; check if flag is set
	pop	bc
	ret	nz		; if yes, return
	call	TWAIT		; else move task to waiting list
	ret
flw3:	ld	a,E.BADFL
	scf
	ret

	END
