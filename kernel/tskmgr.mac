;**********************************************************************;
;                                                                      ;
;   This file is part of RSX180, a multi-tasking OS for the Z180.      ;
;   Copyright (C) 1985-2019, Hector Peraza.                            ;
;                                                                      ;
;   This program is free software; you can redistribute it and/or      ;
;   modify it under the terms of the GNU General Public License as     ;
;   published by the Free Software Foundation; either version 2 of     ;
;   the License, or (at your option) any later version.                ;
;                                                                      ;
;   This program is distributed in the hope that it will be useful,    ;
;   but WITHOUT ANY WARRANTY; without even the implied warranty of     ;
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      ;
;   GNU General Public License for more details.                       ;
;                                                                      ;
;   You should have received a copy of the GNU General Public License  ;
;   along with this program; if not, write to the Free Software        ;
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.          ;
;                                                                      ;
;**********************************************************************;

	NAME	('TSKMGR')
	TITLE	'RSX180 Task Management'

;----------------------------------------------------------------------;
;                                                                      ;
;	Task management routines.                                      ;
;                                                                      ;
;----------------------------------------------------------------------;

	.Z80

; Note: compile with ZSM4 (M80 reverses chars in 'CO', etc.)

	include	TCB.INC
	include	PCB.INC
	include	DCB.INC
	include	LCB.INC
	include	CLKQ.INC
	include	SYSFN.INC
	include	ERRORS.INC

	cseg

	public	DSPTCH		; dispatch next ready task
	public	GO		; initial system start
	public	$LKTCB		; link TCB to a list
	public	INITKM		; initialize task manager
	public	NEWTCB		; allocate new TCB
	public	$FNTSK		; find task by name
	public	$FNTCB		; locate TCB in active task list
	public	FTCB		; locate TCB in the specified list
	public	ALTPRI		; change task priority
	public	TSETSV		; switch privileged task into supervisor mode
	public	TCLRSV		; switch privileged task back to user mode
	public	TRQST,TRQST2	; start (request) an installed task
	public	TKILL		; kill (abort) a task
	public	TREM		; remove a task from the STD
	public	TSTOP		; stop a task
	public	TRESUM		; resume a task
	public	TFIX		; fix task in memory
	public	TUNFIX		; unfix task from memory
	public	TMRKT		; mark time request
	public	TCMKT		; cancel mark time request
	public	TSRUN		; start task at specified time
	public	TCSRQ		; cancel scheduled task request
	public	TWAIT		; wait for flag
	public	TCONT		; continue task execution after event
	public	TGO		; start task execution once loaded
	public	TALLOC		; allocate task memory
	public	TFREE		; free task memory
	public	FRECMD		; free command line block
	public	EXTTSK		; extend task size
	public	CTSK?		; check HL for current task
	public	CHKTP		; check task privileges

	public	NEWCTX,SETCTX	; needed by the startup code

	extrn	$TLIST,$RLIST,$WLIST,$PLIST,$FORKQ,$CLKQ,$CTCB,$CPCB
	extrn	$ERSEQ,$MVTBL,$PHYDV,$LOGDV,SFLAGS

	extrn	INTACK,INTOFF,INTON,SYSENT,SYSSTK,SYSXIT,DSPFLG
	extrn	SYSBBR,USRBBR,UGETB,$MCOPY,UPUTBB,CHKCLQ,CLRFLG
	extrn	MALLOC,MFREE,$ALLOC,$FREE,CLRMEM,CLRCVL,CLNAST
	extrn	UCBAR,SCBAR,IOKILL,QLDR,QTKTN,$FNDEV,TFLAG,DOFORK
	extrn	TRPFLG,CHKTRP,MEXTND,CLQADD,CLNCLQ,TICCNT,$FNPAR
	extrn	DISCON,MCRTCB,LDRTCB

;-----------------------------------------------------------------------

; Initialize task manager: init lists, queues, tables, etc.
; Called only during system startup.

INITKM:	xor	a
	ld	(DSPFLG),a	; clear dispatch flag
	ld	(TRPFLG),a	; clear trap flag
	ld	hl,0
	ld	($CTCB),hl	; no current TCB yet
	ld	($CPCB),hl	; no current PCB either
;;	ld	($PLIST),hl	; clear partition list
;;	ld	($TLIST),hl	; clear system task directory
	ld	($RLIST),hl	; clear ready list
	ld	($WLIST),hl	; clear wait list
	ld	($FORKQ),hl	; clear fork queue
	ld	($CLKQ),hl	; clear clock queue
	ld	($ERSEQ),hl	; reset error counter
;;	ld	($PHYDV),hl	; reset physical device table (DCB list)
;;	ld	($LOGDV),hl	; reset logical-to-physical xlt table
	ld	($MVTBL),hl	; reset mounted volume table
	ld	hl,SFLAGS
	ld	bc,8
	call	CLRMEM		; clear system flags
	ret

;-----------------------------------------------------------------------

; Dispatch next task in ready list.

DSPTCH:	ld	hl,($RLIST)	; get first TCB from ready list
	ld	a,h
	or	l		; null task?
	jr	z,dsp1		; branch if yes
	push	hl
	pop	ix
	ld	l,(ix)		; else unlink it
	ld	h,(ix+1)
	ld	($RLIST),hl	; set new top TCB, IX = old TCB
	ld	iy,$RLIST
	ld	bc,T.LNK
	call	$LKTCB		; now link the TCB to end of priority list
dsp1:	ld	hl,($RLIST)	; get next ready TCB
	ld	a,h
	or	l		; null task?
	jr	nz,dsp3		; dispatch it if not
dsp2:	call	DOFORK		; else dispatch fork queue
	jr	nc,dsp2
	ld	hl,TFLAG
	ld	a,(hl)
	ld	(hl),0
	or	a
	call	nz,CHKCLQ	;  and clock queue
	jr	dsp1		; loop until a task becomes ready
dsp3:	ld	($CTCB),hl	; set as current TCB
	ld	bc,T.PCB
	add	hl,bc
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	($CPCB),hl	; set current partition
	ld	bc,P.BASE
	add	hl,bc
	ld	a,(hl)
	ld	(USRBBR),a
	ret

; Start the system

GO:	call	INTON		; enable timer interrupts
	call	DSPTCH		; dispatch first ready task
	jp	SYSXIT		; go run task

;-----------------------------------------------------------------------

; Link TCB to the end of the chain of tasks with the same priority.

; Input:
;   IX = address of TCB to add to chain
;   BC = offset to link field in TCB (T.LNK or T.TCBL)
;   IY = head of list to link this TCB to
; Preserves IX.

$LKTCB:	ld	e,(iy)		; get link field into DE
	ld	d,(iy+1)
	ld	a,d
	or	e		; check if zero
	jr	z,lnk2		; if yes, we reached the end of the list
	ld	hl,T.PRI
	add	hl,de
	ld	a,(hl)		; else get priority from task in chain
	cp	(ix+T.PRI)	; compare with this task's priority
	jr	c,lnk2		; jump if task with lower priority found
	push	de
	pop	iy		; else go to next item in list
	add	iy,bc
	jr	$LKTCB		; and try again

; we arrive here with:
;   IY = prev TCB +T.LNK or +T.TCBL in list or list head ptr
;   DE = current TCB in list
;   IX = address of TCB to insert

lnk2:	push	ix		; get address of TCB to insert
	pop	hl		;  into HL
	ld	(iy),l		; set prev pointer in list
	ld	(iy+1),h
	add	hl,bc
	ld	(hl),e		; set next field on inserted TCB
	inc	hl
	ld	(hl),d
	ret

;-----------------------------------------------------------------------

; Allocate a new TCB from kernel memory pool.

; Returns:
;   HL = address of TCB
;   CY flag set if not enough memory for new TCB.

; Note: call with interrupts disabled to prevent two different tasks
; from getting the same TCB. Interrupts should be enabled only after
; the TCB has been linked into a list.

NEWTCB:	ld	bc,TCBSZ	; TCB size
	call	$ALLOC		; allocate new TCB
	ld	a,E.NOMEM
	ret	c		; return if not enough memory
	ld	e,l		; get allocated TCB address also into DE
	ld	d,h
	ld	bc,TCBSZ
	call	CLRMEM		; not strictly necessary...
	ex	de,hl		; return TCB address in HL
	xor	a
	ret

;-----------------------------------------------------------------------

; Start (request) an installed task. The TCB is reset, memory for the
; task is allocated and a request is sent to the loader to load the task
; from disk. Once the task is started, the TCB is moved to the active
; list.

; Input:
;   HL = address of task descriptor in user space, values used are:
;        - name of task to request
;        - console device
;        - user and group numbers
;        - address of command line block
;        - TA.MCR attribute
;        any other values (e.g. other attributes and priority) are
;        ignored since task is already installed
; Returns:
;   IX = task TCB address
;   CY flag set on error

; TODO:
; - use $CTCB console and session values if user did not specify a TDB

TRQST:	push	hl
	ld	bc,TD.NAME
	add	hl,bc
	ld	c,l
	ld	b,h
	call	$FNTSK		; find task by name
	pop	iy		; get TDB into IY
	ret	c		; return error if not found
	push	hl
	pop	ix		; else get TCB into IX
TRQST2:	bit	TS.ACT,(ix+T.ST); task active?
	jr	z,trq1		; jump if not
	xor	a
	bit	TA.CLI,(ix+T.ATTR) ; else check if task is a CLI
	ret	nz		   ; return success if yes
	bit	TA.ACP,(ix+T.ATTR) ; an ACP?
	ret	nz		   ; return success as well
	ld	a,E.TRUN	; else return error - task already active
	scf
	ret

trq1:	ld	a,(ix+T.ATTR)
	res	TA.AST,a	; ASTs are initially disabled
	res	TA.MCR,a
	bit	TA.MCR,(iy+TD.ATTR)
	jr	z,trq2
	set	TA.MCR,a

trq2:	ld	(ix+T.ATTR),a	; reset attributes

	ld	a,(ix+T.DPRI)
	ld	(ix+T.PRI),a	; reset priority to default

	ld	a,(ix+T.DEND)
	ld	(ix+T.END),a	; reset end address to default
	ld	a,(ix+T.DEND+1)
	ld	(ix+T.END+1),a

	xor	a
	ld	(ix+T.FLGS),a	; clear all flags
	ld	(ix+T.FLGS+1),a
	ld	(ix+T.FLGS+2),a
	ld	(ix+T.FLGS+3),a
	ld	(ix+T.WAIT),a	; clear wait mask
	ld	(ix+T.WAIT+1),a
	ld	(ix+T.WAIT+2),a
	ld	(ix+T.WAIT+3),a

	bit	TA.FIX,(ix+T.ATTR)
	jr	nz,trq3		; skip if task is fixed in memory
	ld	(ix+T.CTX),a	; clear context block address
	ld	(ix+T.CTX+1),a

trq3:	ld	(ix+T.CMD),a	; clear command line
	ld	(ix+T.CMD+1),a
	ld	(ix+T.RCVL),a	; clear receive list
	ld	(ix+T.RCVL+1),a
	ld	(ix+T.OCBL),a	; clear OCB list
	ld	(ix+T.OCBL+1),a
	ld	(ix+T.ASTL),a	; clear AST list
	ld	(ix+T.ASTL+1),a
	ld	(ix+T.AST),a	; clear AST routine address
	ld	(ix+T.AST+1),a
	ld	(ix+T.ASTP),a	; clear AST param block address
	ld	(ix+T.ASTP+1),a
	ld	(ix+T.IOC),a	; clear outstanding I/O count

	ld	e,(iy+TD.CON)
	ld	d,(iy+TD.CON+1)
	ld	c,(iy+TD.CON+2)
	push	ix
	push	iy
	ld	ix,($CTCB)
	call	$FNDEV
	pop	iy
	pop	ix
	ret	c
	ld	(ix+T.TI),l	; set UCB of terminal
	ld	(ix+T.TI+1),h
	push	hl
	ex	(sp),ix
	call	UCBNAM##
	pop	ix
	ld	(ix+T.CON),e	; set terminal name
	ld	(ix+T.CON+1),d
	ld	(ix+T.CON+2),c

	bit	TA.FIX,(ix+T.ATTR) ; task fixed in memory?
	jr	nz,trq4		   ; skip memory allocation if yes

	call	GETSIZ		; compute required space
	ret	c		; return error if task too big
				; TODO: remove if TA.REM? or call TKTN?

	push	iy
	call	TALLOC		; allocate space for task
	pop	iy
	ret	c		; return error if no available memory
				; TODO: remove if TA.REM? or call TKTN?

	call	NEWCTX		; allocate and link new context block
	jr	c,trqe		; return if not enough pool memory

trq4:	call	SETCTX		; setup task context

	push	iy
	ld	iy,$WLIST
	ld	bc,T.LNK	; insert TCB in waiting list
	call	$LKTCB		;  with TS.OUT bit set unless fixed
	pop	iy

	set	TS.ACT,(ix+T.ST); status = active, all other bits zero
	set	TS.IOW,(ix+T.ST); status = I/O waiting (not yet loaded)
	res	TS.STP,(ix+T.ST)
	res	TS.WTD,(ix+T.ST)
	res	TS.AST,(ix+T.ST)
	res	TS.SUP,(ix+T.ST)

	bit	TA.FIX,(ix+T.ATTR) ; task fixed in memory?
	jr	z,trq5		   ; jump if not

	bit	TS.OUT,(ix+T.ST); task already loaded?
	jr	z,TGO		; then start task immediately

	push	ix
	pop	hl

	xor	a		; else a loader request is in progress,
	ret			;  return success

trq5:	set	TS.OUT,(ix+T.ST); status = out of memory (not yet loaded)

	push	ix
	pop	hl		; HL = task TCB address
	push	ix
	call	QLDR		; queue TCB to loader
	pop	ix
	ret			; return TCB address in IX

	; operation failed, free allocated resources and return error code

trqe0:	push	af
	bit	TA.FIX,(ix+T.ATTR)
	call	z,FRECTX	; free the context block if task not fixed
	pop	af
trqe:	push	af
	bit	TA.FIX,(ix+T.ATTR)
	call	z,TFREE		; free allocated task memory
	pop	af		; return error code
	ret

; Start task execution.

TGO:	res	TS.OUT,(ix+T.ST); task in memory (loaded)
	bit	TS.ACT,(ix+T.ST); task active?
	ret	z		; return if not (fix request) [check?]
	ld	l,(ix+T.PCB)
	ld	h,(ix+T.PCB+1)
	ld	de,P.BASE
	add	hl,de
	ld	a,(hl)		; get bank
	ld	c,(ix+T.EPT)
	ld	b,(ix+T.EPT+1)	; get entry point into BC
	ld	e,(ix+T.END)
	ld	d,(ix+T.END+1)	; DE = initial top of stack
;;	inc	de
	ld	hl,-22
	add	hl,de		; correct for pushed registers
	ld	(ix+T.SP),l	; set the real SP in TCB
	ld	(ix+T.SP+1),h
	ex	de,hl		; initial top of stack now in HL
	di
	ld	e,a		; dest bank in E
	dec	hl
	ld	a,b		; setup return address in task's stack
	call	UPUTBB		;  in user space
	dec	hl
	ld	a,c
	call	UPUTBB
	ei
	push	ix
	pop	bc
	jp	TCONT		; move task to ready list

; Allocate Task Context Block and link it to TCB.
; Called with IX = TCB.

NEWCTX:	ld	bc,CTXSZ	; Context Block size
	push	ix
	call	$ALLOC		; allocate new Context Block
	pop	ix
	ret	c		; return error if not enough memory
	ld	(ix+T.CTX),l	; set pointer in TCB
	ld	(ix+T.CTX+1),h
	ld	bc,CTXSZ
	call	CLRMEM		; clear block
	xor	a
	ret

; Initialize Task Context Block.
; Called with HL = addr of Context Block, IX = TCB, IY = TDB.

SETCTX:	ld	l,(ix+T.TI)	; get UCB of terminal
	ld	h,(ix+T.TI+1)
	ld	de,U.LCB
	add	hl,de
	ld	e,(hl)		; get LCB address into DE
	inc	hl
	ld	d,(hl)
	ld	l,(ix+T.CTX)	; get context address into HL
	ld	h,(ix+T.CTX+1)
	push	ix
	ld	ix,($CTCB)
	bit	TA.PRV,(ix+T.ATTR) ; is the requesting task privileged?
	jr	z,sc1		; branch if not

	xor	a
	ld	(iy+TD.USR),a	; else force session UIC
	ld	(iy+TD.GRP),a

sc1:	push	hl
	pop	ix		; IX = task context block

	ld	a,(iy+TD.USR)
	or	a
	jr	nz,sc2

	ld	a,d
	or	e		; valid LCB?
	ld	a,1
	jr	z,sc2

	ld	hl,L.USR
	add	hl,de
	ld	a,(hl)

sc2:	ld	(ix+TX.UID),a	; set user ID

	ld	a,(iy+TD.GRP)
	or	a
	jr	nz,sc3

	ld	a,d
	or	e		; valid LCB?
	ld	a,1
	jr	z,sc3

	ld	hl,L.GRP
	add	hl,de
	ld	a,(hl)

sc3:	ld	(ix+TX.GID),a	; set group ID

	ld	a,d
	or	e
	jr	nz,sc4

	push	ix
	pop	hl
	ld	de,TX.DIR
	add	hl,de
	ld	bc,9
	call	CLRMEM		; clear current dir
	pop	ix		; restore TCB address
	ret

sc4:	ld	hl,L.CDIR
	add	hl,de		; src = L.CDIR field of LCB
	ex	de,hl
	push	ix
	pop	hl
	ld	bc,TX.DIR
	add	hl,bc
	ex	de,hl		; dst = TX.DIR field of context block
	ld	bc,9
	ldir			; set task's current directory
	pop	ix		; restore TCB address
	ret

;-----------------------------------------------------------------------

; Fix task in memory.

; Input:
;   BC = valid task TCB address
; Returns:
;   CY flag set on error (e.g. task active)

;  TS.OUT  TA.FIX
;  ------  ------
;     0       0     task not in memory
;     0       1     task in memory and fixed
;     1       0     task not fixed and being loaded
;     1       1     task fixed and being loaded

TFIX:	call	CHKTP		; privileged operation
	ret	c

	push	bc
	pop	ix		; get TCB into IX
	bit	TS.ACT,(ix+T.ST)
	ld	a,E.TACT	; task active
	scf
	ret	nz

	bit	TA.FIX,(ix+T.ATTR)
	ld	a,E.TFIX	; task already fixed
	scf
	ret	nz

FIX:	call	GETSIZ		; compute required space
	ret	c		; return error if task too big

	call	TALLOC		; allocate space for task
	ret	c		; return error if no available memory

	call	NEWCTX		; allocate and link new context block
	jp	c,trqe		; return if not enough pool memory

	xor	a
	set	TS.OUT,a	; status = out of memory, all other bits = 0
	ld	(ix+T.ST),a

	set	TA.FIX,(ix+T.ATTR) ; set fixed attrib here, after succesful
				   ; TALLOC and NEWCTX

	push	ix
	pop	hl		; HL = task TCB address
	call	QLDR		; queue TCB to loader
	ret

;-----------------------------------------------------------------------

; Unfix task (remove from memory).

; Input:
;   BC = valid task TCB address
; Returns:
;   CY flag set on error (e.g. task active)

TUNFIX:	call	CHKTP		; privileged operation
	ret	c

	push	bc
	pop	ix		; get TCB into IX
	bit	TS.ACT,(ix+T.ST)
	ld	a,E.TACT	; task active
	scf
	ret	nz

UNFIX:	bit	TA.FIX,(ix+T.ATTR)
	ld	a,E.TNFIX	; task not fixed
	scf
	ret	z
	res	TA.FIX,(ix+T.ATTR)

	ld	l,(ix+T.PCB)
	ld	h,(ix+T.PCB+1)
	ld	de,P.BASE
	add	hl,de
	ld	a,(SYSBBR)
	sub	(hl)		; task in kernel bank/partition?
	ret	z		; return success (A=0) if yes

	call	trqe0		; else release task mem and context block
	xor	a
	ret

;-----------------------------------------------------------------------

; Compute required task size from file size and information in TCB.

; Input:
;   IX = task TCB
; Returns:
;   HL = number of bytes to allocate, rounded to the 4K page granularity
;        of the P112.
;   CY set and error code in A if task image will not fit in memory.

GETSIZ:	ld	l,(ix+T.NBLK)
	ld	h,(ix+T.NBLK+1)	; get file size in blocks
	ld	a,h
	or	a
	ld	a,E.PBIG
	scf
	ret	nz		; program too big

	ld	a,l
	or	a
	ld	a,E.BADTF
	scf			; number of blocks can't be zero
	ret	z

	ld	a,l
	cp	120		; (65536-4096)/512 = 120
	ccf
	ld	a,E.PBIG
	ret	c		; program too big

	ld	l,(ix+T.END)	; check task's upper limit
	ld	h,(ix+T.END+1)
	inc	hl		; size = end address + 1
	ld	de,4095		; (pagesize-1) for rounding
	add	hl,de
	ld	a,E.PBIG
	ret	c		; task won't fit in memory

	ld	a,h
	and	0F0h		; round to page size
	ld	d,a
	ld	e,0		; DE = (T.END+1) + INC rounded to page size
	cp	240		; (65536-4096)/4096*16 = 240
	ccf
	ld	a,E.PBIG
	ret	c		; program too big

	ld	h,(ix+T.NBLK)	; low(T.NBLK)
	ld	l,0		; *256
	add	hl,hl		; *512  HL = file size rounded to page size

	call	cpdehl		; (T.END+1) + INC > T.NBLK * 512?
	ret	nc		; allocate T.NBLK * 512 bytes if not
	ex	de,hl		; else allocate (T.END+1) + INC bytes
	xor	a		; clear CY
	ret

;-----------------------------------------------------------------------

; Kill a task: remove task from active list, free task memory and
; optionally remove TCB from STD. Aborted tasks are reconnected to
; TKTN, which displays a message on the user console and emits abort
; status to parents.

; Input:
;   BC = valid task TCB address
;   E = abort code, 0 for normal exit
; Returns:
;   CY flag set on error (e.g. task not active)

; TODO:
;   - check privileges
;   - ensure that all allocated resources are freed

TKILL:	call	CHKSYS
	ld	a,E.BADOP
	ret	c
	di
	ld	hl,T.ST
	add	hl,bc
	bit	TS.ACT,(hl)	; task active?
	ld	a,E.TNAC
	scf
	ret	z		; error if not
	push	de
	call	DISCON		; disconnect from offspring tasks
	push	bc
	call	CLRCVL		; purge receive list
	pop	ix
	call	CLRCMD		; purge command line
	push	ix
	call	CLNAST		; purge AST queue
	pop	ix
	push	ix
	ld	c,CT.MKT	; mark time request (leave run requests)
	ld	b,0FFh		; any event flags
	call	CLNCLQ		; purge clock queue
	pop	bc
	call	IOKILL		; delete pending I/O requests
	pop	de
	or	e		; add outstanding I/O bit to reason code
	ld	e,a
	push	de
	push	bc
	pop	ix
	bit	TA.FIX,(ix+T.ATTR)
	call	z,FRECTX	; delete the context block if task not fixed
	ld	iy,$TLIST
	ld	de,T.TCBL	; find task in STD
	call	FTCB		; IX=TCB, IY=prev
	pop	de
	jr	c,tk1
	bit	TA.REM,(ix+T.ATTR); remove on exit?
	jr	z,tk0		; jump if not
	ld	a,(ix+T.TCBL)	; else remove TCB from task directory
	ld	(iy),a
	ld	a,(ix+T.TCBL+1)
	ld	(iy+1),a
	res	TA.FIX,(ix+T.ATTR) ; and clear the 'fixed' attribute
tk0:	push	de
	call	$FNTCB		; find task in active list: IX=TCB, IY=prev
	pop	bc		; reason now in reg C
	ld	a,E.TNAC
	jr	c,tk1		; return error if task not active
				;  (should not happen, we checked above for
				;   this condition)
	push	ix
	pop	hl		; get TCB address into HL
	ld	de,($CTCB)
	call	cpdehl		; was it the current task?
	push	af		; save comparison result
	ld	a,(ix)		; get link field into BC
	ld	(iy),a		; update link of previous TCB
	ld	a,(ix+1)	;  (unlink TCB from active list)
	ld	(iy+1),a
	res	TS.ACT,(ix+T.ST); clear active bit

	ld	a,c		; check abort code
	or	a		; normal exit?
	jr	z,tk3		; jump if yes
	push	hl
	push	ix
	call	QTKTN		; else post message to TKTN and request it
	pop	ix
	pop	hl

tk3:	push	hl		; push TCB address

	bit	TA.FIX,(ix+T.ATTR); task fixed in memory?
	jr	nz,tk31		  ; jump if yes, do not release memory

	ld	l,(ix+T.PCB)
	ld	h,(ix+T.PCB+1)
	ld	de,P.BASE
	add	hl,de
	ld	a,(SYSBBR)
	cp	(hl)		; task in kernel bank/partition?
	call	nz,TFREE	; release task memory if not (IX = TCB address)

tk31:	pop	ix		; pop TCB address back into IX
	bit	TA.REM,(ix+T.ATTR); remove on exit?
	jr	z,tk2		; jump if not
	push	ix
	pop	hl		; get TCB address into HL
	ld	de,TCBSZ
	call	$FREE		; release TCB
tk2:	pop	af		; was it the current task?
	jp	z,GO		; dispatch next task if yes
	xor	a		; otherwise return to caller
tk1:	ei
	ret

; Free the command line block.

CLRCMD:	ld	l,(ix+T.CMD)
	ld	h,(ix+T.CMD+1)
FRECMD:	ld	a,h		; get command line block address into HL
	or	l
	ret	z		; return if none
	ld	e,(hl)		; get length into DE
	ld	d,0
	inc	de		; +1 because size field
	push	ix
	call	$FREE
	pop	ix
	ret

; Delete the Task Context Block. Assumes any open files have been closed
; by the cleanup routine.

FRECTX:	ld	l,(ix+T.CTX)
	ld	h,(ix+T.CTX+1)
	ld	a,h
	or	l
	ret	z
	ld	de,CTXSZ
	push	ix
	push	bc
	call	$FREE		; free the context block
	pop	bc
	pop	ix
	xor	a
	ld	(ix+T.CTX),a	; clear pointer in TCB
	ld	(ix+T.CTX+1),a
	ret

; Return CY set if FCB in BC corresponds to one of the system tasks
; (LDR, MCR, but not TKTN or SYSFCP).

CHKSYS:	ld	hl,(MCRTCB)
	call	CPHLBC
	scf
	ret	z
	ld	hl,(LDRTCB)
	call	CPHLBC
	scf
	ret	z
	or	a
	ret

CPHLBC:	ld	a,b
	cp	h
	ret	nz
	ld	a,c
	cp	l
	ret

;-----------------------------------------------------------------------

; Remove a task from the STD. Task cannot be active, or an error occurs.

; Input:
;   BC = task TCB address
; Returns:
;   CY flag set if task not found

; TODO:
;   - check privileges

TREM:	call	CHKTP		; check current task privileges
	ret	c		; return if not privileged
	ld	iy,$TLIST
	ld	de,T.TCBL
	call	FTCB		; IX=TCB, IY=prev
	ret	c
	bit	TS.ACT,(ix+T.ST); task active?
	ld	a,E.TACT
	scf
	ret	nz		; return error if yes
	call	UNFIX		; unfix and release memory if fixed
	push	ix
	push	iy
	ld	c,CT.RUN	; run requests
	ld	b,0FFh		; any event flags
	call	CLNCLQ		; remove any scheduled packets from clk queue
	pop	iy
	pop	ix
	ld	a,(ix+T.TCBL)	; remove TCB from task directory
	ld	(iy),a
	ld	a,(ix+T.TCBL+1)
	ld	(iy+1),a
	push	ix
	call	TCSRQ1		; remove any scheduled execution requests
	pop	hl		; TCB address now in HL
	ld	de,TCBSZ
	call	$FREE		; release TCB
	xor	a		; clear error flag
	ret			; and return

;-----------------------------------------------------------------------

; Stop a task.

; Input:
;   BC = TCB address
; Returns:
;   CY flag set if task not found
;   A = 0 on success
;   A = 1 if task already stopped

; TODO:
;   - check privileges.

TSTOP:	call	$FNTCB		; find task in active list: IX=TCB, IY=prev
	ret	c
	bit	TS.AST,(ix+T.ST); task in AST state?
	jr	nz,stp1		; jump if yes
	ld	a,(ix+T.ST)	; get task status
	and	TM.RUN		; mask 'running' bits, active task?
	jr	z,stp0		; skip next check if yes
	bit	TS.STP,(ix+T.ST); already stopped?
	ld	a,E.TSTP
	scf
	ret	nz		; if yes, return with 'already stopped' code
stp0:	ld	a,(ix+T.LNK)	; get link field
	ld	(iy),a		; update link of previous TCB (unlink)
	ld	a,(ix+T.LNK+1)
	ld	(iy+1),a
	ld	iy,$WLIST
	ld	bc,T.LNK
	call	$LKTCB		; link task to waiting task list
	set	TS.STP,(ix+T.ST); set status bit
	push	ix
	pop	hl
	call	CTSK?		; if task was current task, dispatch next
	xor	a		; return success
	ret

stp1:	bit	TS.STP,(ix+T.SVST) ; main thread already stopped?
	ld	a,E.TSTP
	scf
	ret	nz		   ; if yes, return with 'already stopped' code
	set	TS.STP,(ix+T.SVST) ; set status bit
	xor	a		; return success
	ret			; task will be stopped upon AST exit

CTSK?:	ld	de,($CTCB)
	call	cpdehl
	ret	nz
	ld	a,1
	ld	(DSPFLG),a	; set redispatch flag
	ret			; (we can't call DSPTCH until we return
				;  from SYSFN)

cpdehl:	ld	a,h
	cp	d
	ret	nz
	ld	a,l
	cp	e
	ret

;-----------------------------------------------------------------------

; Resume task.

; Input:
;   BC = TCB address
; Returns:
;   CY flag set if task not found
;   A = 0 on success (task will become active if no other status
;                     bits are set)
;   A = 1 if task not stopped (but not neccessarily running)

; TODO:
;   - check privileges

TRESUM:	call	$FNTCB		; find task in active list: IX=TCB, IY=prev
	ret	c
	bit	TS.AST,(ix+T.ST); task in AST state?
	jr	nz,res3		; jump if yes
	bit	TS.STP,(ix+T.ST); check stop bit
	ld	a,E.TRUN
	jr	z,res2		; if not set, return error
	res	TS.STP,(ix+T.ST); else clear stop bit
	ld	a,(ix+T.ST)
	and	TM.RUN		; task became active?
	jr	nz,res1		; return if not
	ld	a,(ix+T.LNK)	; get link field
	ld	(iy),a		; update link of previous TCB (unlink)
	ld	a,(ix+T.LNK+1)
	ld	(iy+1),a
	ld	iy,$RLIST
	ld	bc,T.LNK
	call	$LKTCB		; move task to ready list
res1:	xor	a
res2:	or	a
	ret

res3:	bit	TS.STP,(ix+T.SVST) ; check saved stop bit
	ld	a,E.TRUN
	jr	z,res2		   ; if not set, return error
	res	TS.STP,(ix+T.SVST) ; else clear stop bit
	xor	a		; return success
	ret			; task will resume execution upon AST exit

;-----------------------------------------------------------------------

; Mark Time request.

; Input:
;   IY = TCB address ($CTCB)
;   HLDE = tick count (relative to current time)
;   C = event flag number
; Returns:
;   CY flag set on error and error code in A

TMRKT:	ld	b,CT.MKT	; request type
	push	iy
	push	bc
	call	TMRQST		; queue the request
	pop	de		; E = flag number
	pop	bc		; BC = TCB
	ret	c		; on error return
	call	CLRFLG		; clear event flag
	ret

;-----------------------------------------------------------------------

; Cancel Mark Time request.

; Input:
;   IY = TCB address ($CTCB)
;   C = event flag number, or 0FFh to remove all requests
; Returns:
;   CY flag set on error and error code in A

TCMKT:	ld	b,c		; get event flag into B
	ld	c,CT.MKT	; mark time request (leave run requests)
	push	iy
	pop	ix
	call	CLNCLQ		; purge clock queue
	ret

;-----------------------------------------------------------------------

; Request task at specified time.

; Input:
;   HL = TDB address
;   DEBC = tick count (relative to current time)
; Returns:
;   CY flag set on error and error code in A

TSRUN:	call	CHKTP		; check task privileges
	ret	c
	push	de
	push	bc
	ld	bc,TD.NAME
	add	hl,bc
	ld	c,l
	ld	b,h
	call	$FNTSK		; find task by name
	push	hl
	pop	iy		; get TCB address into IY
	pop	de
	pop	hl		; schedule interval now in HLDE
	ret	c
	ld	b,CT.RUN	; request type
	ld	c,0		; event flag not used for CT.RUN
TMRQST:	ld	ix,TICCNT
	di
	ld	a,e
	add	a,(ix)
	ld	e,a		; compute absolute time from relative
	ld	a,d		;  for clock queue
	adc	a,(ix+1)
	ld	d,a
	ld	a,l
	adc	a,(ix+2)
	ld	l,a
	ld	a,h
	adc	a,(ix+3)
	ld	h,a
	ei
	call	CLQADD		; queue the request
	ret

;-----------------------------------------------------------------------

; Cancel scheduled task request.

; Input:
;   IX = TCB address
; Returns:
;   CY flag set on error and error code in A

TCSRQ:	call	CHKTP		; check task privileges
	ret	c
TCSRQ1:	ld	b,0FFh		; cancel all requests
	ld	c,CT.RUN	;  of type run
	call	CLNCLQ		; purge clock queue
	ret

;-----------------------------------------------------------------------

; Wait for flag. Mask of flag(s) to wait for should have been already
; set in T.WAIT.

; Input:
;   BC = TCB address
; Returns:
;   CY set on error and error code in A

; TODO:
;   - check privileges.

TWAIT:	push	de
	call	$FNTCB		; find task in active list: IX=TCB, IY=prev
	pop	bc
	ret	c
;;	bit	TS.AST,(ix+T.ST); task in AST state?
;;	ld	a,E.BADOP
;;	scf
;;	ret	nz		; return error if yes - operation not allowed
	ld	a,(ix+T.ST)
	and	TM.RUN		; active task?
	jr	z,tw1		; skip next test if yes
	bit	TS.IOW,(ix+T.ST); already waiting?
	ld	a,E.TSTP
	scf
	ret	nz		; if yes, return error
tw1:	ld	a,(ix+T.WAIT)	; check wait mask
	or	(ix+T.WAIT+1)
	or	(ix+T.WAIT+2)
	or	(ix+T.WAIT+3)
	ld	a,E.INV
	scf
	ret	z		; nothing to wait for, return error
	ld	a,(ix+T.LNK)	; get link field
	ld	(iy),a		; update link of previous TCB (unlink)
	ld	a,(ix+T.LNK+1)
	ld	(iy+1),a
	ld	iy,$WLIST
	ld	bc,T.LNK
	call	$LKTCB
	set	TS.IOW,(ix+T.ST); pause task
	push	ix
	pop	hl
	call	CTSK?		; if task was current task, dispatch next
	xor	a		; return success
	ret

;-----------------------------------------------------------------------

; Wakeup the specified task. Usually called upon setting an I/O flag.

; Input:
;   BC = TCB address
; Returns:
;   CY flag set if task not found
;   A = 0 on success (task will become active if no other status
;                     bits are set)
;   A = 1 if task not stopped (but not neccessarily running)

; TODO:
;   - check privileges

TCONT:	call	$FNTCB		; find task in active list: IX=TCB, IY=prev
	ret	c
;;	bit	TS.AST,(ix+T.ST); task in AST state
;;	jr	nz,tc33		; jump if yes
	bit	TS.IOW,(ix+T.ST); task waiting?
	ld	a,E.TRUN
	jr	z,tc32		; return error (NZ) if not
	res	TS.IOW,(ix+T.ST); else clear waiting bit
	ld	a,(ix+T.ST)
	and	TM.RUN		; task became active?
	jr	nz,tc31		; return if not
	ld	a,(ix+T.LNK)	; get link field
	ld	(iy),a		; update link of previous TCB (unlink)
	ld	a,(ix+T.LNK+1)
	ld	(iy+1),a
	ld	iy,$RLIST
	ld	bc,T.LNK
	call	$LKTCB		; move task to ready list
tc31:	xor	a
tc32:	or	a
	ret

;;tc33:	bit	TS.IOW,(ix+T.SVST) ; main thread waiting?
;;	ld	a,E.TRUN
;;	jr	z,tc32		   ; return error (NZ) if not
;;	res	TS.IOW,(ix+T.SVST) ; else clear waiting bit
;;	xor	a		; return success
;;	ret			; task will (eventually) become active
;;				;  upon AST exit

;-----------------------------------------------------------------------

; Change the priority of a task.

; Input:
;   BC = TCB address
;   E  = new priority, zero to reset priority to default value
;   D  = which priority to set: 0 = running, 1 = installed
; Returns:
;   CY flag set on error and error code in A

; TODO:
; - if the current task changes its priority to a lower value it may be
;   immediately preempted. If the current task gives another task a
;   higher priority than its own, the current task will be immediately
;   preempted.

ALTPRI:	ld	hl,T.DPRI
	add	hl,bc
	ld	a,e
	or	a		; reset priority to default?
	jr	nz,altp1	; jump if not
	ld	e,(hl)
	jr	altp2

altp1:	ld	a,(hl)
	cp	e		; is new priority higher than default?
	jr	c,altp3		; jump if yes, task must be privileged

altp2:	ld	a,d
	or	a		; altering default priority?
	jr	nz,altp3	; jump if yes, task must be privileged

	ld	hl,($CTCB)	; changing priority of another task?
	ld	a,h
	cp	b
	jr	nz,altp3
	ld	a,l
	cp	c
	jr	z,altp4		; jump if not

altp3:	call	CHKTP		; else current task must be privileged
	ret	c		; return error if not

altp4:	ld	a,d
	or	a		; change running priority only?
	jr	z,altp5		; jump if yes

	push	de
	push	bc
	ld	iy,$TLIST
	ld	de,T.TCBL	; search STD
	call	FTCB		; IX=TCB, IY=prev
	pop	bc
	pop	de
	ret	c		; return error if task not found
	ld	(ix+T.PRI),e	; set new running priority
	ld	(ix+T.DPRI),e	; and also the default priority
	ld	a,(ix+T.TCBL)	; remove TCB from task directory
	ld	(iy),a
	ld	a,(ix+T.TCBL+1)
	ld	(iy+1),a
	push	de
	push	bc
	ld	iy,$TLIST
	ld	bc,T.TCBL
	call	$LKTCB		; reinsert TCB according to new priority
	pop	bc
	pop	de

altp5:	push	de
	push	bc
	ld	iy,$RLIST
	ld	de,T.LNK
	call	FTCB		; search running list
	pop	bc
	pop	de
	jr	c,altp6		; jump if not found here
	ld	(ix+T.PRI),e	; set running priority
	ld	a,(ix+T.LNK)	; remove TCB from ready list
	ld	(iy),a
	ld	a,(ix+T.LNK+1)
	ld	(iy+1),a
	ld	iy,$RLIST
	ld	bc,T.LNK
	call	$LKTCB		; reinsert TCB according to new priority
	xor	a
	ret

altp6:	push	de
	push	bc
	ld	iy,$WLIST
	ld	de,T.LNK
	call	FTCB		; last, search waiting list
	pop	bc
	pop	de
	jr	c,altp7		; jump if not found here
	ld	(ix+T.PRI),e	; set running priority
	ld	a,(ix+T.LNK)	; remove TCB from waiting list
	ld	(iy),a
	ld	a,(ix+T.LNK+1)
	ld	(iy+1),a
	ld	iy,$WLIST
	ld	bc,T.LNK
	call	$LKTCB		; reinsert TCB according to new priority
altp7:	xor	a
	ret

;-----------------------------------------------------------------------

; Switch the current (privileged) task to supervisor mode.
; Will take effect after returning from system service.

; Input:
;   --
; Returns:
;   A = 0 on success
;   A = error code if not enough privileges 

TSETSV:	ld	ix,($CTCB)
	xor	a
	bit	TS.SUP,(ix+T.ST)
	ret	nz		; already in supervisor mode
	bit	TA.PRV,(ix+T.ATTR)
	ld	a,E.PRIV
	scf
	ret	z		; not a privileged task
	set	TS.SUP,(ix+T.ST)
	xor	a
	ret

;-----------------------------------------------------------------------

; Switch the current task back to user mode.
; Will take effect after returning from system service.
; Input:
;   --
; Returns:
;   A = 0 on success (always)

TCLRSV:	ld	ix,($CTCB)
	res	TS.SUP,(ix+T.ST)
	xor	a
	ret

;-----------------------------------------------------------------------

; Find a task by name in the STD list and return its TCB address.

; Input:
;   BC = addr of task name (6 chars)
; Returns:
;   HL = task TCB address
;   CY flag set if task cannot be found.

; Notes:
; - Call this function only when in system level (SYSLVL=-1).

$FNTSK:	ld	hl,$TLIST
FTSK:	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	dec	hl
	ex	de,hl		; DE=prev, HL=next
	ld	a,h
	or	l
	ld	a,E.TNF		; 'task not found' error
	scf
	ret	z
	push	bc
	push	hl
	ld	de,T.NAME	; name offset
	add	hl,de
	ld	d,6		; name length
ftsk2:	ld	a,(bc)
	cp	(hl)
	jr	nz,ftsk3	; jump if no match
	inc	hl
	inc	bc
	dec	d
	jr	nz,ftsk2	; loop unitl all chars processed
	pop	hl		; found, return this TCB
	pop	bc
	xor	a
	ret
ftsk3:	pop	hl
	ld	bc,T.TCBL
	add	hl,bc
	pop	bc
	jr	FTSK

;-----------------------------------------------------------------------

; Locate the TCB of the task in the active list and return list
; pointers for subsequent insert/remove operations.

; Input:
;   BC = task TCB address
; Returns:
;   IX = TCB address
;   IY = addr of link field in prev TCB
;   CY flag set if the task cannot be found.
; Preserves BC

; Notes:
; - Should be called with SYSLVL=-1 (otherwise with interrupts disabled).

$FNTCB:	ld	de,T.LNK
	ld	iy,$RLIST
	call	FTCB
	ret	nc
	ld	iy,$WLIST
FTCB:	ld	l,(iy)		; get link value into HL
	ld	h,(iy+1)
	ld	a,h		; zero?
	or	l
	ld	a,E.TNF
	scf			; then return with error (TCB not found)
	ret	z
	ld	a,l
	cp	c		; compare TCB addresses
	jr	nz,fndt1
	ld	a,h
	cp	b
	jr	nz,fndt1
	push	hl
	pop	ix		; if match, get TCB address into IX
	xor	a		; and return success
	ret
fndt1:	add	hl,de		; else add link offset (T.LNK or T.TCBL)
	push	hl
	pop	iy		; move TCB address to IY
	jr	FTCB		; and loop

;UNLTCB:
;	call	FTCB
;	ret	c
;	ld	a,(ix)
;	ld	(iy),a
;	ld	a,(ix+1)
;	ld	(iy+1),a
;	ret

;-----------------------------------------------------------------------

; Allocates memory for task. Assumes task space starts at 0000h.
; Also initializes page zero with system and debugger entry point
; vector (last should be allowed only for priv tasks).

; Input:
;   IX = TCB
;   HL = requested task size
; Returns:
;   D = task bank number
;   E = number of allocated pages
;   CY set on error

TALLOC:	call	GETNP		; compute required number of pages
	ld	e,a		; E = num pages
	cp	10h		; should be in the 00-0F range (0000-EFFF)
	ccf
	ld	a,E.NOMEM
	ret	c		; prevent overwriting the commom segment
	ld	l,(ix+T.PCB)	; get pointer to partition
	ld	h,(ix+T.PCB+1)
	ld	bc,P.MAIN
	add	hl,bc
	ld	a,(hl)		; get pointer to main partition
	inc	hl
	ld	h,(hl)
	ld	l,a
	push	hl
	pop	iy
	bit	PA.SYS,(iy+P.ATTR) ; system-controlled partition?
	jr	nz,ta1		; jump if yes

	; task partition [TODO: merge with MALLOC in pars.mac?]

	bit	PS.BSY,(iy+P.STAT) ; partition busy?
	ld	a,E.PBSY
	scf
	ret	nz		; error if yes
	ld	a,(iy+P.SIZE)
	cp	e		; partition large enough?
	ld	a,E.NOMEM
	ret	c		; error if not
	set	PS.BSY,(iy+P.STAT)
	jr	ta2		; continue via common code

ta1:	; system-controlled partition

	push	ix
	call	MALLOC		; allocate memory, returns IX = sub PCB
	push	ix
	pop	iy
	pop	ix
	ret	c		; return if not enough memory
ta2:	ld	e,(iy+P.SIZE)
	ld	d,(iy+P.BASE)
	push	iy
	pop	bc
	ld	(ix+T.PCB),c	; set pointer to subpartition PCB in TCB
	ld	(ix+T.PCB+1),b
	push	ix
	pop	bc
	ld	(iy+P.TCB),c	; set pointer to TCB in subpartition PCB
	ld	(iy+P.TCB+1),b
	push	de		; save bank# and number of allocated pages
	ld	e,d		; dest bank in E
	ld	d,8
	ld	hl,0		; vector address
ta3:	ld	bc,CHKTRP	; setup default trap handler
	call	TSETV
	ld	bc,8-2
	add	hl,bc
	dec	d
	jr	nz,ta3
	ld	hl,SYSRST	; vector address
	ld	bc,SYSENT	; setup syscall RST
	call	TSETV
	ld	hl,DBGRST	; vector address
	ld	bc,T_EPT##	; setup debug RST
	call	TSETV
	pop	de		; restore bank# and number of allocated pages
	xor	a		; return success
	ret

; compute required number of pages from value in HL

GETNP:	push	hl
	push	de
	ld	de,4095
	add	hl,de		; round task size to page limit
	ld	a,h
	rra			; note we're pushing in the CY bit
	rra			;  from addition above in case it overflowed
	rra
	rra
	and	1Fh
	pop	de
	pop	hl
	ret

; set jump vector in bank E at address HL to target address in BC

TSETV:	di
	ld	a,0C3h		; jp instruction code
	call	UPUTBB
	inc	hl
	ld	a,c		; target address
	call	UPUTBB
	inc	hl
	ld	a,b
	call	UPUTBB
	ei
	ret

;-----------------------------------------------------------------------

; Unload task from memory. Task must have been killed, the TCB is
; unlinked, but still contains valid data. This procedure is called
; with interrupts disabled.

; Input:
;   IX = TCB

; TODO:
;  - compute the real starting BBR value (will be different from
;    P.BASE if task is loaded at an address different from 100h
;    (say, at 8000h). Right now assumes all tasks start at 100h

TFREE:	ld	e,(ix+T.PCB)
	ld	d,(ix+T.PCB+1)
	push	de
	ex	(sp),ix		; push TCB, pop PCB
	ld	l,(ix+P.MAIN)	; get pointer to main PCB
	ld	h,(ix+P.MAIN+1)
	push	hl
	pop	iy
	bit	PA.SYS,(iy+P.ATTR) ; system-controlled partition?
	jr	nz,tf1		; jump if yes

	; task partition [TODO: merge with MALLOC in pars.mac?]

	res	PS.BSY,(iy+P.STAT)
	jr	tf2		; continue via common code

tf1:	; system-controlled partition

	push	hl
	call	MFREE
	pop	hl
tf2:	pop	ix
	ld	(ix+T.PCB),l	; replace subpartition PCB with main PCB
	ld	(ix+T.PCB+1),h
	xor	a
	ret

;-----------------------------------------------------------------------

; Extend task size. Assumes task space starts at 0000h.

; Input:
;   IX = task TCB
;   HL = increment in bytes, 0 to restore installed size
; Returns:
;   CY set on error and error code in A.

; TODO:
; - return error if task has outstanding I/O and new size caused either
;   the task to shrink, or to relocate to a new region

EXTTSK:	ex	de,hl		; get increment into DE
	ld	l,(ix+T.END)	; and current end address into HL
	ld	h,(ix+T.END+1)
	inc	hl		; size = end address + 1
	add	hl,de		; HL = new end address (size)
	ld	a,d
	or	e		; zero increment?
	jr	nz,newsz	; jump if not
	ld	l,(ix+T.DEND)	; else restore default size
	ld	h,(ix+T.DEND+1)
	inc	hl
newsz:	call	GETNP		; compute new size in pages
	ld	c,a		; save it in C
	push	hl
	ld	e,(ix+T.PCB)	; get subpartition PCB
	ld	d,(ix+T.PCB+1)
	ld	hl,P.SIZE
	add	hl,de
	cp	(hl)		; same number of pages as before?
	pop	hl
	ld	a,E.OK
	jr	z,stend		; if yes, set new end address and return
	ld	a,c
	cp	10h		; max allowed number of pages is 15
	ccf
	ld	a,E.NOMEM
	ret	c		; prevent overwriting the commom segment
	ld	a,c
	or	a
	ld	a,E.INV
	scf
	ret	z		; zero size is illegal

	push	de
	ex	(sp),ix		; IX now has subpartition PCB
	ld	e,c
	ld	b,(ix+P.BASE)
	push	hl
	push	bc
	call	MEXTND		; extend partition
	pop	bc
	pop	hl
	ld	d,(ix+P.BASE)	;;; redundant
	pop	ix		; pop TCB back into IX
	ret	c		; failed
	ld	a,d
	cp	b		; partition relocated?
	jr	z,stend		; set new end address and return if not

	push	hl
	push	de
	push	bc
	di
	ld	a,d
	exx
	ld	d,a		; D' = dst bank
	exx
	ld	a,b
	exx
	ld	e,a		; E' = src bank
	exx
	ld	hl,0
	ld	de,0
	ld	c,(ix+T.END)
	ld	b,(ix+T.END+1)
	inc	bc
	call	$MCOPY		; re-locate task to new region
	ei
	pop	bc
	pop	de
	pop	hl

	;TODO: update USRBBR if IX == ($CTCB)?

stend:	dec	hl
	ld	(ix+T.END),l	; set new task end
	ld	(ix+T.END+1),h
	xor	a
	ret			; return success

;-----------------------------------------------------------------------

; Check if current task is privileged.

; Input:
;   $CTCB = TCB of current task
; Output:
;   CY flag set and error code in A if task not privileged.

CHKTP:	push	hl
	push	de
	call	cktp1
	pop	de
	pop	hl
	ret

cktp1:	ld	hl,($CTCB)
	ld	a,h
	or	l
	ret	z
	ld	de,T.ATTR
	add	hl,de
	bit	TA.PRV,(hl)
	ret	nz
	ld	a,E.PRIV
	scf
	ret			; return error if not

	END
