;**********************************************************************;
;                                                                      ;
;   This file is part of RSX180, a multi-tasking OS for the Z180.      ;
;   Copyright (C) 1985-2019, Hector Peraza.                            ;
;                                                                      ;
;   This program is free software; you can redistribute it and/or      ;
;   modify it under the terms of the GNU General Public License as     ;
;   published by the Free Software Foundation; either version 2 of     ;
;   the License, or (at your option) any later version.                ;
;                                                                      ;
;   This program is distributed in the hope that it will be useful,    ;
;   but WITHOUT ANY WARRANTY; without even the implied warranty of     ;
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      ;
;   GNU General Public License for more details.                       ;
;                                                                      ;
;   You should have received a copy of the GNU General Public License  ;
;   along with this program; if not, write to the Free Software        ;
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.          ;
;                                                                      ;
;**********************************************************************;

	NAME	('AST')
	TITLE	'RSX180 AST Processing'

;----------------------------------------------------------------------;
;                                                                      ;
;	AST queuing and dispatching routines.                          ;
;                                                                      ;
;----------------------------------------------------------------------;

	.Z80

	include	ERRORS.INC
	include	TCB.INC
	include	PCB.INC
	include	AST.INC

	cseg

	public	ASTDCL		; declare AST
	public	ASTCTL		; enable/disable AST
	public	ASTEXT		; exit from AST
	public	QAST		; queue AST
	public	DOAST		; execute AST
	public	CLNAST		; AST cleanup on task exit

	extrn	$CTCB,$FREE,USRBBR,SYSBBR,$MCOPY,UGETWB,UPUTWB
	extrn	$FNTCB,$LKTCB,$RLIST,$WLIST,CKWMSK,TCONT,TNEXT

;-----------------------------------------------------------------------

; Declare an AST processing routine for the current task.
; Call with interrupts disabled or when SYSLVL=-1.
;
; Input:
;   BC = address of routine to call or zero to disable AST processing.
;   DE = address of param block.
; Returns:
;   CY set on error, A = error code

ASTDCL:	ld	ix,($CTCB)
	ld	(ix+T.AST),c	; set routine address
	ld	(ix+T.AST+1),b
	ld	(ix+T.ASTP),e	; set param block address
	ld	(ix+T.ASTP+1),d
	ld	a,b
	or	c		; no AST routine (disabling AST)?
	call	z,CLNAST	;  then purge AST queue
	xor	a
	ret

;-----------------------------------------------------------------------

; Enable/Disable AST processing for ASTs of the given type(s).
;
; Input:
;   E = AST type mask
;   D = 0 to disable, <>0 to enable

ASTCTL:	ld	ix,($CTCB)
	ld	a,d
	or	a		; enable or disable?
	ld	a,e
	jr	z,aset2		; jump if disable
	or	(ix+T.SAST)
	ld	(ix+T.SAST),a	; set event bits in T.SAST
	xor	a
	ret
aset2:	cpl
	and	(ix+T.SAST)
	ld	(ix+T.SAST),a	; clear event bits in T.SAST
	xor	a
	ret

;-----------------------------------------------------------------------

; Append an AST event block to the specified task's AST queue and modify
; task status to begin AST execution.
;
; Input:
;   IX = address of AST block to add to list
;   IY = task TCB
; Preserves IX.
;
; Assumes an AST routine has been specified and that the event type is
; accepted (checks done by caller).
;
; Note: Do not call from an interrupt routine. Device drivers must use
; fork processing to send ASTs to requesting tasks.

QAST:	push	iy
	ld	de,T.ASTL
	add	iy,de
lnk1:	ld	e,(iy)		; get link field into DE
	ld	d,(iy+1)
	ld	a,d
	or	e		; check if zero
	jr	z,lnk2		; if yes, we reached the end of the list
	push	de
	pop	iy		; else go to next AST event block in list
	jr	lnk1		; and try again

; we arrive here with:
;   IY = prev AST block in list or list head ptr
;   IX = address of AST block to add

lnk2:	push	ix		; get address of AST block to insert
	pop	hl		;  into HL
	ld	(iy),l		; set prev pointer in list
	ld	(iy+1),h
	ld	(ix),e		; clear next field on inserted AST block
	ld	(ix+1),d
	pop	ix
	; continue below

;-----------------------------------------------------------------------

; Setup task for AST execution.
;
; Moves the task to the ready list and sets the TS.AST bit in T.ST.
; The task will be resumed normally via SYSXIT.
;
; If the task is checkpointed, it will be kept in the wait list and the
; partition wait queue checked. Eventually, the task will be assigned a
; (sub)partition, loaded back into memory and resumed.
;
; Input:
;   IX = TCB address

SETAST:	bit	TS.AST,(ix+T.ST); is task already in AST mode?
	jp	nz,ast0		; return success if yes

	ld	l,(ix+T.AST)
	ld	h,(ix+T.AST+1)
	ld	a,h		; AST processing enabled?
	or	l
	scf
	ret	z		; return error if not

  IF 0
	ld	l,(ix+T.ASTL)
	ld	h,(ix+T.ASTL+1)
	ld	a,h		; check AST queue
	or	l
	scf
	ret	z		; return error if empty
  ENDIF

	ld	l,(ix+T.CTX)
	ld	h,(ix+T.CTX+1)
	push	hl
	pop	iy		; get task context address into IY
	ld	a,h
	or	l
	scf
	ret	z		; error if not set

	ld	a,(ix+T.ST)
	ld	(ix+T.SVST),a	; save old task status
	ld	a,(ix+T.ST+1)
	ld	(ix+T.SVST+1),a
	ld	a,(ix+T.WAIT)
	ld	(iy+TX.SWM),a	; save old wait mask
	ld	a,(ix+T.WAIT+1)
	ld	(iy+TX.SWM+1),a
	ld	a,(ix+T.WAIT+2)
	ld	(iy+TX.SWM+2),a
	ld	a,(ix+T.WAIT+3)
	ld	(iy+TX.SWM+3),a
	xor	a
	ld	(ix+T.WAIT),a	; clear wait mask
	ld	(ix+T.WAIT+1),a
	ld	(ix+T.WAIT+2),a
	ld	(ix+T.WAIT+3),a
	set	TS.ACT,a
	set	TS.AST,a
	ld	(ix+T.ST),a	; set new task status (note: TS.SUP is clear)
	ld	a,(ix+T.SVST+1)
	or	a		; was task runnable?
	ret	z		; return success if yes
	res	T2.STP,a
	res	T2.EFW,a
	res	T2.WTD,a
	ld	(ix+T.ST+1),a
	or	a		; task runnable in new AST state?
	jp	nz,TNEXT	; must be out of memory, try bringing it back
	push	ix
	pop	bc
	call	$FNTCB		; locate task, returns IX=TCB and IY=prev
	ret	c		; should not happen
	ld	a,(ix+T.ACTL)	; unlink TCB
	ld	(iy),a
	ld	a,(ix+T.ACTL+1)
	ld	(iy+1),a
	ld	iy,$RLIST
	ld	bc,T.ACTL
	call	$LKTCB		; move task to ready list
ast0:	xor	a		; task will be resumed normally via SYSXIT
	ret

;-----------------------------------------------------------------------

; Remove an AST block from the current task's T.ASTL queue and deliver
; it to the task.
;
; This routine is called from SYSXIT, meaning the task is runnable and
; loaded in memory at this point.
;
; Any registers modified in AST mode must be saved/restored by the task.

DOAST:	ld	ix,($CTCB)
	ld	l,(ix+T.ASTL)
	ld	h,(ix+T.ASTL+1)
	ld	a,h		; check AST queue
	or	l
	ret	z		; return if empty

	push	hl		; save address of AST block
	inc	hl
	inc	hl
	inc	hl
	ld	a,(hl)		; check type
	cp	AST.ST OR 80h	; special AST status block?
	pop	iy
	jr	nz,ast1

	ld	a,(iy+A.LNK)
	ld	(ix+T.ASTL),a	; unlink it from queue
	ld	a,(iy+A.LNK+1)
	ld	(ix+T.ASTL+1),a
	ld	l,(iy+A.DAT)	; get ECB address
	ld	h,(iy+A.DAT+1)
	ld	c,(iy+A.DAT+2)	; get status
	ld	b,(iy+A.DAT+3)
	ld	a,(USRBBR)
	ld	e,a		; dst bank
	di
	call	UPUTWB		; store status
	ei
	ld	e,(iy+A.SIZ)
	ld	d,0
	ld	hl,AHSZ		; add header size
	add	hl,de
	ex	de,hl		; DE = AST block size
	push	iy
	pop	hl		; HL = AST block address
	call	$FREE		; free the AST block
	jr	DOAST		; loop to dispatch next

ast1:	call	SETAST		; switch task to AST mode if necessary
	ret	c		; on error, return

	bit	TS.AST,(ix+T.SVST) ; already executing an AST?
	ret	nz		   ; return if yes
	set	TS.AST,(ix+T.SVST) ; else set the status bit

	ld	l,(ix+T.CTX)
	ld	h,(ix+T.CTX+1)
	push	hl
	pop	iy		; get task context address into IY

	push	ix
	ld	l,(ix+T.ASTL)	; get address of first AST block in list
	ld	h,(ix+T.ASTL+1)
	push	hl		; save it
	ld	a,(hl)
	ld	(ix+T.ASTL),a	; unlink it from queue
	inc	hl
	ld	a,(hl)
	ld	(ix+T.ASTL+1),a
	inc	hl
	ld	c,(hl)		; size of data area
	ld	b,0
	push	bc		; save it
	inc	bc		; BC = len (include type)
	inc	hl		; HL = src (type + data area)
	ld	e,(ix+T.ASTP)
	ld	d,(ix+T.ASTP+1)	; DE = dst
	di
	exx
	ld	a,(USRBBR)
	ld	d,a		; D' = dst bank
	ld	a,(SYSBBR)
	ld	e,a		; E' = src bank
	exx
	call	$MCOPY		; copy full param block + type to task space
	ei
	pop	de		; pop size of data area into DE
	ld	hl,AHSZ		; add header size
	add	hl,de
	ex	de,hl		; DE = AST block size
	pop	hl		; HL = AST block address
	call	$FREE		; free the AST block
	pop	ix
	ld	a,(USRBBR)
	ld	e,a		; get task bank into reg E
	ld	c,(ix+T.SP)
	ld	b,(ix+T.SP+1)
	ld	hl,20		; offset to PC in task's stack frame
	add	hl,bc
	push	hl		; save PC offset
	di
	call	UGETWB		; fetch PC value
	ld	(iy+TX.PC),c	; save it
	ld	(iy+TX.PC+1),b
	pop	hl		; restore PC offset
	ld	c,(ix+T.AST)
	ld	b,(ix+T.AST+1)	; HL = address of AST routine
	call	UPUTWB		; set PC = AST routine address
	ei
	xor	a		; return success
	ret

;-----------------------------------------------------------------------

; Exit from AST.
;
; Restores PC, status bits and the wait-for mask from saved values and
; clears the TS.AST bit.
;
; If the task was/is not runnable (e.g. stopped, waiting, etc.), it
; will be placed back into the wait list.

ASTEXT:	ld	ix,($CTCB)
	bit	TS.AST,(ix+T.SVST) ; AST under execution?
	scf
	ret	z		   ; return error if not
	res	TS.AST,(ix+T.SVST) ; else clear the status bit

	pop	bc		; discard SVRSLT return address!

	ld	l,(ix+T.CTX)
	ld	h,(ix+T.CTX+1)
	push	hl
	pop	iy		; get address of task context block into IY
	ld	a,(USRBBR)
	ld	e,a		; get task bank into reg E
	ld	c,(ix+T.SP)
	ld	b,(ix+T.SP+1)
	ld	hl,20		; offset to PC in task's stack frame
	add	hl,bc
	ld	c,(iy+TX.PC)	; get saved PC value into BC
	ld	b,(iy+TX.PC+1)
	di
	call	UPUTWB		; restore old PC
	ei

	ld	l,(ix+T.AST)
	ld	h,(ix+T.AST+1)
	ld	a,h		; AST processing still enabled?
	or	l
	jr	z,astx2		; exit AST mode if not

	ld	e,(ix+T.ASTL)
	ld	d,(ix+T.ASTL+1)
astx1:	ld	a,d		; check AST queue
	or	e
	jr	z,astx2		; exit AST mode if empty
	ld	hl,A.TYP
	add	hl,de
	ld	a,(hl)
	cp	AST.ST OR 80h	; special AST status blocks do not count
	ret	nz
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	jr	astx1

astx2:	ld	a,(iy+TX.SWM)
	ld	(ix+T.WAIT),a	; restore old wait mask
	ld	a,(iy+TX.SWM+1)
	ld	(ix+T.WAIT+1),a
	ld	a,(iy+TX.SWM+2)
	ld	(ix+T.WAIT+2),a
	ld	a,(iy+TX.SWM+3)
	ld	(ix+T.WAIT+3),a
	ld	a,(ix+T.SVST)
	ld	(ix+T.ST),a	; restore old task status
	ld	a,(ix+T.SVST+1)
	res	T2.OUT,a	; clear T2.OUT and T2.CKP bit in case the task
	res	T2.CKP,a	;  was checkpointed when the AST was queued
	ld	(ix+T.ST+1),a
	or	a		; task in running state?
	ret	z		; return if yes (already in $RLIST)
	push	ix
	pop	bc
	call	$FNTCB		; locate task, returns IX=TCB and IY=prev
	ret	c		; should not happen
	ld	a,(ix+T.ACTL)	; unlink TCB
	ld	(iy),a
	ld	a,(ix+T.ACTL+1)
	ld	(iy+1),a
	ld	iy,$WLIST
	ld	bc,T.ACTL
	call	$LKTCB		; move task back to wait list
	bit	T2.EFW,(ix+T.ST+1) ; task waiting on flag?
	ret	z		   ; return if not
	push	ix
	pop	bc
	push	bc
	call	CKWMSK		; check wait mask
	pop	bc
	ret	c		; return on error
	ret	z		; return if no flag is set
	jp	TCONT		; else wakeup task (BC = TCB)

;-----------------------------------------------------------------------

; Remove all AST blocks from the specified task T.ASTL queue.
; Called on task exit during cleanup.
;
; Input:
;   IX = TCB
; Preserves IX.

CLNAST:	xor	a
	ld	(ix+T.AST),a	; disable further ASTs
	ld	(ix+T.AST+1),a
cln1:	ld	l,(ix+T.ASTL)
	ld	h,(ix+T.ASTL+1)
	ld	a,h
	or	l
	ret	z		; return if queue empty.
	push	ix
	push	hl
	ld	a,(hl)
	ld	(ix+T.ASTL),a	; unlink the AST block
	inc	hl
	ld	a,(hl)
	ld	(ix+T.ASTL+1),a
	inc	hl
	ld	e,(hl)		; get size of data area into DE
	ld	d,0
	ld	hl,AHSZ		; add header size
	add	hl,de
	ex	de,hl		; block size in DE
	pop	hl		; block address in HL
	call	$FREE		; free the AST block
	pop	ix
	jr	cln1		; continue until all blocks are removed

	END
