	.Z80

	include	SYSFN.INC
	include	QIO.INC
	include	TCB.INC
	include	DCB.INC
	include	ERRORS.INC

WBOOT	equ	0
BDOS	equ	5

CR	equ	0Dh
LF	equ	0Ah

TILUN	equ	5

	public	RSXEMU,EMU

	extrn	CRLF,PUTCH,PUTSTR,AHEX,TTFLSH

	CSEG

RSXEMU:	ld	hl,SYSRST
	ld	(hl),0C3h	; setup system call vector
	inc	hl
	ld	de,EMU
	ld	(hl),e
	inc	hl
	ld	(hl),d
	ld	hl,luntbl+5*4
	ld	(hl),'T'
	inc	hl
	ld	(hl),'T'
	inc	hl
	ld	(hl),0
	ret

EMU:	ex	(sp),hl
	ld	a,(hl)		; get function code
	inc	hl
	ex	(sp),hl
	cp	.GDAT
	jr	z,gdat
	cp	.GTCMD
	jr	z,gcmd
	cp	.QIO
	jr	z,qio
	cp	.ALUN
	jp	z,alun
	cp	.GTLUN
	jp	z,gtlun
	cp	.GTSK
	jp	z,gtsk
	cp	.EXIT
	jp	z,exit
	cp	.MRKT
	jp	z,ignore
	cp	.CMKT
	jp	z,ignore
	cp	.RQST
	jp	z,spawn
	cp	.WTFLG
	jp	z,ignore
	push	af
	call	CRLF		; note recursive call via SYSLIB
	ld	hl,unsup
	call	PUTSTR		; function not supported
	pop	af
	call	AHEX
	call	CRLF
	call	TTFLSH
	jp	exit

; Get command line

gcmd:	ld	c,e		; get max length into BC
	ld	b,0
	ex	de,hl		; dst in DE
	ld	hl,80h		; src in HL
	ldir			; copy CP/M command
	xor	a
	ret

; Get current date

gdat:	ld	(hl),20h	; fake date
	inc	hl
	ld	(hl),16h
	inc	hl
	ld	(hl),03h
	inc	hl
	ld	(hl),17h
	xor	a
	ret

; Queue I/O - always waits, only terminal supported, no file I/O

qio:	push	hl
	ex	(sp),ix		; save IX, get HL into IX
	ld	bc,qret
	push	bc		; push return address
	ld	a,(ix+Q.FUNC)
	cp	IO.WVB
	jp	z,wvb
	cp	IO.RVB
	jp	z,rvb
	cp	IO.ATT
	jp	z,att
	cp	IO.DET
	jp	z,det
	cp	IO.ACC
	jp	z,acc
	pop	bc
	pop	ix
error:	scf
	ret

; Write virtual block

wvb:	ld	l,(ix+Q.BUF)	; get buffer address into HL
	ld	h,(ix+Q.BUF+1)
	ld	c,(ix+Q.LEN)	; get length into DE
	ld	b,(ix+Q.LEN+1)
	push	bc
wvb1:	ld	a,b
	or	c
	jr	z,wvb2
	ld	e,(hl)
	push	hl
	push	bc
	ld	c,6
	call	BDOS		; output char to console
	pop	bc
	pop	hl
	inc	hl
	dec	bc
	jr	wvb1
wvb2:	pop	bc
	ld	l,(ix+Q.IOSB)
	ld	h,(ix+Q.IOSB+1)
	inc	hl
	inc	hl
	ld	(hl),c		; store length
	inc	hl
	ld	(hl),b
	ld	bc,0
	xor	a
	ret

qret:	ld	l,(ix+Q.IOSB)
	ld	h,(ix+Q.IOSB+1)
	ld	(hl),c		; store result code
	inc	hl
	ld	(hl),b
	pop	ix
	ret

att:	ld	bc,0
	xor	a
	ret

det:	ld	bc,0
	xor	a
	ret

acc:	ld	bc,E.FNF
	scf
	ret

; Read virtual block

rvb:	ld	l,(ix+Q.BUF)	; get buffer address into HL
	ld	h,(ix+Q.BUF+1)
	ld	c,(ix+Q.LEN)	; get length into DE
	ld	b,(ix+Q.LEN+1)
	push	bc
rvb1:	ld	a,b
	or	c
	jr	z,rvb3
	push	hl
	push	bc
rvb2:	ld	e,0FFh
	ld	c,6
	call	BDOS		; get char from console
	or	a
	jr	z,rvb2
	pop	bc
	pop	hl
	ld	(hl),a
	inc	hl
	dec	bc
	cp	CR
	jr	nz,rvb1
rvb3:	pop	hl		; pop original length
	or	a
	sbc	hl,bc		; obtain number of chars transferred
	ex	de,hl
	ld	l,(ix+Q.IOSB)
	ld	h,(ix+Q.IOSB+1)
	inc	hl
	inc	hl
	ld	(hl),e		; store length
	inc	hl
	ld	(hl),d
	ld	bc,0
	xor	a
	ret


; Assign LUN

alun:	ld	l,b
	ld	h,0
	add	hl,hl
	add	hl,hl
	push	bc
	ld	bc,luntbl
	add	hl,bc
	pop	bc
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	ld	(hl),c
	xor	a
	ret

; Get LUN info

gtlun:	ld	b,0
	ex	de,hl
	ld	hl,luntbl
	add	hl,bc
	add	hl,bc
	add	hl,bc
	add	hl,bc
	ld	a,(hl)
	ld	bc,3
	ldir
	inc	de
	cp	'T'
	ld	a,0
	jr	z,ttlun
	set	DV.DIR,a
	ld	(de),a
	xor	a
	ret
ttlun:	set	DV.TTY,a
	ld	(de),a
	xor	a
	ret

; Get task info

gtsk:	push	de
	ld	hl,T.END
	add	hl,de
	ld	de,(BDOS+1)
	dec	de
	ld	(hl),e		; store memory top
	inc	hl
	ld	(hl),d
	pop	de
	push	de
	ld	hl,T.NAME
	add	hl,de
	ex	de,hl		; dst in DE
	ld	hl,tskinf
	ld	bc,6
	ldir			; copy task name
	ex	(sp),hl
	ld	de,T.VID
	add	hl,de
	ex	de,hl
	pop	hl
	ld	bc,6
	ldir			; copy version
ignore:	xor	a
	ret

; Spawn

spawn:
	IF	1
	push	bc
	ex	de,hl
	ld	hl,smsg1
	call	PUTSTR
	push	hl
	ld	hl,TD.NAME
	add	hl,de
	ld	b,6
s1:	ld	c,(hl)
	call	PUTCH
	inc	hl
	djnz	s1
	pop	hl
	inc	hl
	call	PUTSTR
	push	hl
	ld	hl,TD.SLEN
	add	hl,de
	ld	c,(hl)
	inc	hl
	ld	b,(hl)
	ld	hl,TD.SDAT
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	inc	hl
	inc	hl
	inc	hl
	inc	hl
	inc	hl
	dec	bc
	dec	bc
	dec	bc
	dec	bc
	dec	bc
	dec	bc		; ignore trailing CR
s2:	push	bc
	ld	c,(hl)
	call	PUTCH
	inc	hl
	pop	bc
	dec	bc
	ld	a,b
	or	c
	jr	nz,s2
	pop	hl
	inc	hl
	call	PUTSTR
	call	TTFLSH
	pop	hl
	ld	bc,EX.SUC
ld bc,4
	ld	(hl),c
	inc	hl
	ld	(hl),b
	xor	a
	ret

smsg1:	db	LF,'Spawning "',0,'", sdat "',0,'"',CR,0
	ELSE
	xor	a
	ret
	ENDIF

; Exit task

exit:	jp	WBOOT

tskinf:	db	'...MCE'
	db	'V4.29 '

unsup:	db	'Unsupported system call ',0

	dseg

luntbl:	rept	16
	dw	0,0
	endm

	END
