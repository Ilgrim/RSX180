;**********************************************************************;
;                                                                      ;
;   This file is part of RSX180, a multi-tasking OS for the Z180.      ;
;   Copyright (C) 1985-2019, Hector Peraza.                            ;
;                                                                      ;
;   This program is free software; you can redistribute it and/or      ;
;   modify it under the terms of the GNU General Public License as     ;
;   published by the Free Software Foundation; either version 2 of     ;
;   the License, or (at your option) any later version.                ;
;                                                                      ;
;   This program is distributed in the hope that it will be useful,    ;
;   but WITHOUT ANY WARRANTY; without even the implied warranty of     ;
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      ;
;   GNU General Public License for more details.                       ;
;                                                                      ;
;   You should have received a copy of the GNU General Public License  ;
;   along with this program; if not, write to the Free Software        ;
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.          ;
;                                                                      ;
;**********************************************************************;

	.Z80

; Note: compile with ZSM4 (M80 reverses chars in 'LB', 'SY', etc.)

Z80182	equ	1
	include	Z180.INC
	include	DCB.INC
	include	TCB.INC
	include	LCB.INC
	include	FCB.INC
	include	QIO.INC
	include	THDR.INC
	include	CLICB.INC
	include	SYSFN.INC
	include	SYSCONF.INC
	include	ERRORS.INC

	public	INIT_S,INIT_E

	extrn	ASSIGN,FNDDEV,FNDTSK,MSIZE,PFN,LOGIN,KALLOC
	extrn	TINS,TRQST,TFIX,QMCR,TKNTCB,MCRTCB,MFLAGS
	extrn	CTCB,CLILST

CR	equ	0Dh
LF	equ	0Ah

SYSCMD	equ	80h		; boot loader stores boot device name here

	cseg

; Notes:
; - This task runs in the system partition, since it makes a few direct
;   kernel calls.
; - Calls that may affect this task's execution state directly or indirectly
;   (i.e. that call TRQST, TINS, etc.) are done via normal system calls to
;   ensure redispatch, etc.
; - Calls that modify the kernel database, but that do not change task state
;   (e.g. ASSIGN, FNDTCB, etc.) are safe to execute if interrupts are kept
;   disabled during the call. That's because we know that we're running in
;   task state (SYSLVL=1) and the kernel is idle (at least until the next
;   timer interrupt). Another way is by explicitely setting SYSLVL=0 during
;   the call to ensure that the kernel dispatcher will not be called on timer
;   interrupt.

KCALL	MACRO	addr
	call	SWSTK##
	dw	addr
	ENDM

;-----------------------------------------------------------------------

; System initialization task. Mounts the system disk, creates logical
; devices, and installs the CLI and other necessary tasks to continue
; booting the system.

INIT_S:	ld	sp,INISTK

	ld	hl,SYSCMD+1
	ld	de,sydev
	ld	bc,3
	ldir			; get boot device passed by boot loader

	call	QIOINI

	ld	hl,LOGMSG
	call	PUTSTR		; display header
	push	hl
	KCALL	MSIZE		; show system memory size
	call	HLDEC
	pop	hl
	inc	hl
	call	PUTSTR
	push	hl
	ld	c,I.VERS
	SC	.GIN
	push	hl
	ld	l,h
	ld	h,0
	call	HLDEC
	ld	c,'.'
	call	PUTCH
	pop	hl
	ld	a,l
	call	ADEC2
	pop	hl
	inc	hl
	call	PUTSTR

	; mount system device

	ld	hl,cmdseq	; implicit startup commands
	call	DEVSTR		; >MOU ddn:
	push	hl
	call	MOUNT		; mount system disk, DE-C set by DEVSTR above
	pop	hl
	jp	c,mnterr

	; setup initial device assignments

	inc	hl
	call	DEVSTR		; >ASN ddn:=LB:
	push	hl
	push	de
	push	bc
	ld	hl,'LB'
	ld	b,0		; 'LB0:' HL-B = logical (system library)
	ld	ix,0
	ld	a,N.GBL
	KCALL	ASSIGN
	pop	bc
	pop	de
	pop	hl

	inc	hl
	call	DEVSTR		; >ASN ddn:=SY:
	push	hl
	ld	hl,'SY'
	ld	b,0		; 'SY0:' HL-B = logical (user system device)
	ld	a,N.GBL ;;N.LGN
	KCALL	ASSIGN

	; login SYSTEM user on TT0:

	ld	de,'TT'
	ld	c,0
	ld	hl,SYSACN	; login SYSTEM user
	KCALL	LOGIN
	jp	c,sserr

	ex	de,hl
	ld	hl,L.ST
	add	hl,de
	set	LS.PRV,(hl)	; set privileged bit

	ld	hl,L.CDIR
	add	hl,de
	ex	de,hl
	ld	hl,SYSACN
	ld	bc,9
	ldir			; set current directory in LCB

	; install INS

	pop	hl
	inc	hl
	call	PRMSTR		; >INS $INS
	push	hl

	ld	de,'TT'
	ld	c,0
	ld	ix,TMPTDB	; install ...INS task
	xor	a
	set	TA.PRV,a	; INS is privileged
	ld	(ix+TD.ATTR),a
	xor	a
	ld	(ix+TD.USR),a
	ld	(ix+TD.GRP),a
	ld	(ix+TD.CON),e
	ld	(ix+TD.CON+1),d
	ld	(ix+TD.CON+2),c
	ld	(ix+TD.END),a
	ld	(ix+TD.END+1),a
	ld	hl,insfn
	ld	de,TMPTDB
	call	INS
	jp	c,inserr

	; install and fix TKTN

	pop	hl
	inc	hl
	call	PRMSTR		; >INS $TKN
	push	hl

	ld	de,'TT'
	ld	c,0
	ld	ix,TMPTDB	; install TKTN task
	xor	a
	set	TA.PRV,a	; TKTN is privileged
	ld	(ix+TD.ATTR),a
	xor	a
	ld	(ix+TD.USR),a
	ld	(ix+TD.GRP),a
	ld	(ix+TD.CON),e
	ld	(ix+TD.CON+1),d
	ld	(ix+TD.CON+2),c
	ld	(ix+TD.END),a
	ld	(ix+TD.END+1),a
	ld	hl,tknfn
	ld	de,TMPTDB
	call	INS
	jp	c,tknerr
	ld	(TKNTCB),hl

	pop	hl
	inc	hl
	call	PRMSTR		; >FIX TKTN
	push	hl

	ld	bc,(TKNTCB)
	KCALL	TFIX

	; install and run MCR

	pop	hl
	inc	hl
	call	PRMSTR		; >INS $MCR/RUN
	push	hl

	ld	de,'TT'
	ld	c,0
	ld	ix,TMPTDB	; install MCR... task
	xor	a
	set	TA.PRV,a	; MCR is privileged
	set	TA.CLI,a	; MCR is a CLI
	set	TA.MCR,a	; set MCR bit as well
	ld	(ix+TD.ATTR),a
	xor	a
	ld	(ix+TD.USR),a
	ld	(ix+TD.GRP),a
	ld	(ix+TD.CON),e
	ld	(ix+TD.CON+1),d
	ld	(ix+TD.CON+2),c
	ld	(ix+TD.END),a
	ld	(ix+TD.END+1),a
	ld	hl,mcrfn
	ld	de,TMPTDB
	call	INS
	jp	c,mcrerr
	ld	(MCRTCB),hl

	ld	de,'TT'
	ld	c,0
	ld	ix,TMPTDB	; request MCR... task
	xor	a
	set	TA.MCR,a	; set MCR bit (else TRQST will clear it)
	ld	(ix+TD.ATTR),a
	ld	a,1
	ld	(ix+TD.USR),a
	ld	(ix+TD.GRP),a
	ld	(ix+TD.CON),e
	ld	(ix+TD.CON+1),d
	ld	(ix+TD.CON+2),c
	ld	(ix+TD.NAME),'M'
	ld	(ix+TD.NAME+1),'C'
	ld	(ix+TD.NAME+2),'R'
	ld	(ix+TD.NAME+3),'.'
	ld	(ix+TD.NAME+4),'.'
	ld	(ix+TD.NAME+5),'.'

	ld	hl,CLIBSZ
	ld	bc,DPRL
	add	hl,bc
	ld	bc,CPRL
	add	hl,bc
	ld	c,l
	ld	b,h
	KCALL	KALLOC		; create CLI control block for MCR
	jp	c,mcrerr	; should not happen

	ld	(CLILST),hl	; add it to CLICB list
	push	hl
	pop	ix
	xor	a
	ld	(ix+CL.LNK),a	; clear link field
	ld	(ix+CL.LNK+1),a
	ld	de,CL.NAM
	add	hl,de
	ex	de,hl
	ld	hl,TMPTDB+TD.NAME
	ld	bc,6
	ldir			; set name
	push	ix
	pop	hl
	ld	de,CL.DAT	; point to data area
	add	hl,de
	ex	de,hl
	ld	hl,DPR
	ld	bc,DPRL
	ld	(ix+CL.DPL),c
	ldir
	ld	hl,CPR
	ld	bc,CPRL
	ld	(ix+CL.CPL),c
	ldir

	ld	hl,TMPTDB
	KCALL	TRQST		; start MCR
	jp	c,mcrerr

	; install the Indirect Command Processor

	pop	hl
	inc	hl
	call	PRMSTR		; >INS $ICP
	push	hl

	ld	de,'TT'
	ld	c,0
	ld	ix,TMPTDB	; install ...AT. task
	xor	a
	set	TA.PRV,a	; AT. is privileged
	ld	(ix+TD.ATTR),a
	xor	a
	ld	(ix+TD.USR),a
	ld	(ix+TD.GRP),a
	ld	(ix+TD.CON),e
	ld	(ix+TD.CON+1),d
	ld	(ix+TD.CON+2),c
	ld	(ix+TD.END),a
	ld	(ix+TD.END+1),a
	ld	hl,icpfn
	ld	de,TMPTDB
	call	INS

	; enable logins

	pop	hl
	inc	hl
	call	PRMSTR		; >SET /LOGON
	push	hl

	ld	hl,MFLAGS
	set	0,(hl)

	; execute startup command file

	pop	hl
	inc	hl
	call	PRMSTR		; >@SY:[SYSTEM]STARTUP.CMD

ICMD	equ	1

	IF	ICMD		; initial MCR command

	ld	hl,inicmd+5
	call	PUTSTR
	ld	hl,inicmd
	ld	de,inilen
	KCALL	QMCR

	ELSE

	ld	hl,inicmd
	ld	de,inilen
	KCALL	QMCR		; empty line to force initial MCR prompt

	ENDIF

	; exit, the startup file will do the rest

exit:	ld	hl,EX.SUC
	SC	.EXIT
	jr	exit

; auxiliary routine: get system device name into DE-C and display a two-part
; string @HL inserting the device name after the first part

DEVSTR:	call	PRMSTR		; display the first part
	push	hl
	ld	hl,sydev
	ld	e,(hl)		; get system device into DE-C
	inc	hl
	ld	d,(hl)
	inc	hl
	ld	c,(hl)
	call	PDEVN		; display device name
	pop	hl
	inc	hl
	jp	PUTSTR		; display the second part and return

LOGMSG:	db	CR,LF,'P112 ',0,'K RSX180 V',0,CR,LF,0

cmdseq:	db	'MOU ',0,CR,0
	db	'ASN ',0,'=LB:',CR,0
	db	'ASN ',0,'=SY:',CR,0
	db	'INS $INS',CR,0
	db	'INS $TKN',CR,0
	db	'FIX TKTN',CR,0
	db	'INS $MCR/RUN',CR,0
	db	'INS $ICP',CR,0
	db	'SET /LOGON',CR,0
	db	0

sydev:	db	'DY',0

insfn:	db	'LB0:[SYSTEM]INS.TSK',0
mcrfn:	db	'LB0:[SYSTEM]MCR.TSK',0
icpfn:	db	'LB0:[SYSTEM]ICP.TSK',0
tknfn:	db	'LB0:[SYSTEM]TKN.TSK',0
noargs:	db	0
	IF	ICMD
inicmd:	db	'TT',0, 0,0, '@SY0:[SYSTEM]STARTUP.CMD',CR,0
inilen	equ	$ - inicmd
	ELSE
inicmd:	db	'TT',0, 0,0, 0
inilen	equ	$ - inicmd
	ENDIF

DPR:	db	CR,LF,'>',0
DPRL	equ	$-DPR

CPR:	db	CR,LF,'MCR>',0
CPRL	equ	$-CPR

SYSACN:	db	'SYSTEM   ',1,1

mnterr:	ld	de,merr
	jr	fatal

merr:	db	'Failed to mount system disk',0

sserr:	ld	de,serr
	jr	fatal

serr:	db	'Failed to initalize system session',0

inserr:	ld	de,ierr
	jr	fatal

ierr:	db	'Failed to install INS',0

tknerr:	ld	de,terr
	jr	fatal

terr:	db	'Failed to install TKTN',0

mcrerr:	ld	de,cerr
fatal:	push	af
	ld	hl,fterr
	call	PUTSTR
	ex	de,hl
	call	PUTSTR
	ex	de,hl
	inc	hl
	call	PUTSTR
	ld	de,5*TCKSEC
	call	SLEEP
	pop	af
  IF 0
	call	INTOFF
  ELSE
	call	T_EPT##
  ENDIF
	di
	halt

cerr:	db	'Failed to run MCR',0

fterr:	db	CR,LF,'RSX180 -- ',0,', system halted.',CR,LF,0

;-----------------------------------------------------------------------

; Mount the device specified in DE-C

MOUNT:	push	de
	push	bc
	ld	a,(lbqio+Q.LUN)
	ld	b,a
	SC	.ALUN		; assign LUN
	pop	bc
	pop	de
	ret	c

	KCALL	FNDDEV		; get UCB of boot device
	ret	c
	push	hl
	pop	ix
	bit	DV.MNT,(ix+U.CW)
	ld	a,E.INV
	scf
	ret	z		; error if not mountable (should not happen)

	push	ix
	ld	bc,acptsk
	KCALL	FNDTSK		; get TCB of file processor
	pop	ix
	ret	c		; error if not installed
	ld	(ix+U.ACP),l	; set U.ACP field of UCB
	ld	(ix+U.ACP+1),h

	ld	hl,IO.MNT	; function code
	ld	(lbqio+Q.FUNC),hl
	ld	hl,lbqio	; now register the unit with the file processor
	SC	.QIO		; .QIOW
	ret	c		; if queueing failed
	ld	a,(iosb)
	or	a		; check result
	ret	z
	scf
	ret

acptsk:	db	'SYSFCP'

;-----------------------------------------------------------------------

; Install task, HL = filename, DE = TDB address

INS:	ld	(tdbadr),de
	call	FOPEN		; open task image file
	ret	c		; return on error

	ld	hl,FDB
	call	FRATTR		; get task image file info

	ld	a,(FDB+F.ATTR)	; check file atrributes
	and	FA.CTG		; contiguous?
	ld	a,E.FNC		; error if not
	jp	z,insrc

	ld	hl,hdr
	ld	bc,0		; block 0
	call	FREAD		; read task header
	jp	c,inscl		; on error close file and exit
	ld	a,h		; read size must be 256 (0100h)
	dec	a
	or	l
	ld	a,E.BADTH
	jp	nz,insrc	; otherwise return error

	call	CHKHDR		; verify task header
	jp	c,inscl		; on error close file and exit

	call	FSIZE		; get file size in bytes into HLDE
	ld	a,h
	or	l
	jp	nz,inspb	; program too big

	ld	hl,-256
	add	hl,de		; subtract header size
	ld	a,E.BADTF
	jp	nc,insrc	; NC here means file too small
	ld	c,l
	ld	b,h

	ld	hl,(hdr+TH.INC)
	add	hl,bc
	jp	c,inspb		; increment too large
	ld	de,4095+100h	; (pagesize-1) for rounding + 100h page zero
	add	hl,de
	jp	c,inspb		; error if program extends beyond F000
				; TODO: get common segment info from kernel!!!
	ld	a,h
	and	0F0h		; round to page size
	ld	h,a
	ld	l,0
	push	hl		; remember task top

	ld	ix,(tdbadr)
	push	ix
	pop	hl
	ld	de,TD.NAME
	add	hl,de
	ex	de,hl
	ld	hl,hdr+TH.NAME	; use default task name from task header
	ld	bc,6
	ldir

	push	ix
	pop	hl
	ld	de,TD.VID
	add	hl,de
	ex	de,hl
	ld	hl,hdr+TH.VID	; set version identification from task header
	ld	bc,6
	ldir

	push	ix
	pop	hl
	ld	de,TD.PAR
	add	hl,de
	ex	de,hl
	ld	hl,hdr+TH.PAR	; set partition name from task header
	ld	bc,6
	ldir

	ld	a,(hdr+TH.PRI)	; set default priority from task header
	ld	(ix+TD.PRI),a

	res	TA.PRV,(ix+TD.ATTR) ; ignore user priv bit
	ld	a,(hdr+TH.PRV)
	or	a		    ; privileged task?
	jr	z,nopriv	    ; jump if not
	set	TA.PRV,(ix+TD.ATTR) ; else set priv bit

nopriv:	ld	iy,FDB
	ld	l,(iy+F.DEV)
	ld	h,(iy+F.DEV+1)
	ld	(ix+TD.LIB),l	; set load device
	ld	(ix+TD.LIB+1),h
	ld	a,(iy+F.UNIT)
	ld	(ix+TD.LIB+2),a	; and unit

	ld	l,(iy+F.STABL)
	ld	h,(iy+F.STABL+1)
	ld	(ix+TD.SBLK),l
	ld	(ix+TD.SBLK+1),h
	ld	(ix+TD.SBLK+2),0
	ld	(ix+TD.SBLK+3),0

	ld	l,(iy+F.NUSED)
	ld	h,(iy+F.NUSED+1)
	ld	(ix+TD.NBLK),l
	ld	(ix+TD.NBLK+1),h

	ld	hl,0
	ld	(ix+TD.STR),l	; task space starts at 0000h
	ld	(ix+TD.STR+1),h
	ld	hl,100h
	ld	(ix+TD.EPT),l	; entry point is at 0100h
	ld	(ix+TD.EPT+1),h
	pop	hl		; pop saved task top
	ld	(ix+TD.SP),l	; set stack to top of task memory
	ld	(ix+TD.SP+1),h
	dec	hl
	ld	(ix+TD.END),l	; set top of task space
	ld	(ix+TD.END+1),h

	ld	hl,(tdbadr)
	KCALL	TINS		; enter the task into the STD
	jr	inscl		; returns with new task ID in HL
				;  and any error code in A

inspb:	ld	a,E.PBIG
insrc:	scf
inscl:	push	af
	push	hl
	call	FCLOSE
	pop	hl
	pop	af
	ret

; Validate task header. Right now it simply checks signature and
; version number.

CHKHDR:	ld	hl,hdr
	ld	de,thid
	ld	b,6
ckhdr:	ld	a,(de)		; check task header ID
	cp	(hl)
	ld	a,E.BADTH
	scf
	ret	nz		; return CY if header is invalid
	inc	hl
	inc	de
	djnz	ckhdr
	ld	hl,(hdr+TH.VER)
	ld	de,0102h	; 1.2
	or	a
	sbc	hl,de
	ret	z
	scf
	ret

thid:	db	'TSK180'

;-----------------------------------------------------------------------

FOPEN:	ld	ix,FDB
	call	PFN
	ld	a,E.BADF
	ret	c
	ld	a,(lbqio+Q.LUN)
	ld	b,a		; LUN in B
	ld	de,(FDB+F.DEV)
	ld	a,(FDB+F.UNIT)
	ld	c,a		; device name in DE-C
	SC	.ALUN
	ret	c
	ld	l,IO.ACC	; function code
	ld	h,SF.ACR OR SF.SHR
	ld	(lbqio+Q.FUNC),hl
	ld	hl,FDB		; FDB address
	ld	(lbqio+Q.P1),hl
	ld	hl,lbqio
	SC	.QIO		; .QIOW
	ret	c		; if queueing failed
	ld	a,(iosb)	; fetch return code
	or	a		; check result
	ret	z
	scf
	ret

FCLOSE:	ld	hl,IO.DEA	; function code
	ld	(lbqio+Q.FUNC),hl
	ld	hl,lbqio
	SC	.QIO		; .QIOW
	ret	c		; if queueing failed
	ld	a,(iosb)
	or	a		; check result
	ret	z
	scf
	ret

FRATTR:	ld	a,IO.RAT
	ld	de,FINFSZ
	jr	frd1

FREAD:	ld	a,IO.RVB
	ld	de,256		; partial block read!
	ld	(lbqio+Q.BLK),bc ; blkno
frd1:	ld	(lbqio+Q.FUNC),a ; function code
	xor	a
	ld	(lbqio+Q.SUBF),a
	ld	(lbqio+Q.BUF),hl ; buf
	ld	(lbqio+Q.LEN),de ; len
	ld	hl,0
	ld	(iosb+2),hl	; clear number of bytes read
	ld	hl,lbqio
	SC	.QIO		; .QIOW
	ret	c		; if queueing failed
	ld	hl,(iosb+2)
	ld	a,(iosb)
	or	a		; check result
	ret	z
	scf
	ret

FSIZE:	ld	a,(FDB+F.ATTR)
	and	FA.CTG		; contiguous file?
	ld	hl,(FDB+F.NUSED)
	jr	nz,fsz1
	ld	hl,(FDB+F.NALOC)
fsz1:	ld	a,h
	or	l
	ld	de,0
	ret	z
	dec	hl		; since last block may not be full
	ld	d,l
	ld	l,h
	ld	h,0		; HLDE = nblocks * 256
	sla	d
	rl	l
	rl	h		; HLDE = nblocks * 512
	ld	bc,(FDB+F.LBCNT)
	ex	de,hl
	add	hl,bc
	ex	de,hl
	ld	bc,0
	adc	hl,bc		; HLDE += lbcnt
	ret
	
;-----------------------------------------------------------------------

PUTCH:	push	hl
	ld	hl,(BUFPTR)
	ld	(hl),c
	inc	hl
	ld	(BUFPTR),hl
	ld	a,(BUFCNT)
	inc	a
	ld	(BUFCNT),a
	cp	80		; buffer full?
	jr	z,pc1		; then output it
	ld	a,c
	cp	CR		; CR?
	jr	z,pc1		; then force output
	pop	hl
	ret

TTFLSH:	push	hl
pc1:	ld	a,(BUFCNT)	; bytes to write
	ld	l,a
	ld	h,0
	ld	(ttqio+Q.LEN),hl
	ld	hl,ttqio
	SC	.QIO		; .QIOW
	jr	c,pc2		; if queueing failed
	ld	a,(iosb)	; fetch return code
	or	a		; check result
	scf
	jr	nz,pc2
	call	inibuf
	xor	a
pc2:	pop	hl
	ret

QIOINI:	ld	de,'LB'
	ld	c,0
	ld	b,1
	SC	.ALUN		; use LUN 1 for disk I/O (LB0:)
	ld	de,'TI'
	ld	c,0
	ld	b,5
	SC	.ALUN		; use LUN 5 for console I/O (TI:)
inibuf:	ld	hl,BUF		; initialize console I/O buffer
	ld	(BUFPTR),hl
	xor	a
	ld	(BUFCNT),a
	ret

;-----------------------------------------------------------------------

PRMSTR:	push	hl
	ld	hl,DPR
	call	PUTSTR
	call	TTFLSH
	ld	a,(TICSEC##)
	srl	a
	srl	a
	srl	a		; 1/8 sec
	ld	e,a
	ld	d,0
	call	SLEEP		; give TI: some time
	pop	hl
PUTSTR:	ld	a,(hl)
	or	a
	ret	z
	push	bc
	push	de
	ld	c,a
	call	PUTCH
	pop	de
	pop	bc
	inc	hl
	jr	PUTSTR

;-----------------------------------------------------------------------

; Display device name in DE-C

PDEVN:	push	hl
	push	bc
	ld	l,c
	ld	h,0
	ld	c,e
	call	PUTCH
	ld	c,d
	call	PUTCH
	call	HLDEC
	ld	c,':'
	call	PUTCH
	pop	bc
	pop	hl
	ret

; Display A as two-digit decimal number

ADEC2:	ld	c,'0'
a2:	cp	10
	jr	c,a1
	inc	c
	sub	10
	jr	a2
a1:	push	af
	call	PUTCH
	pop	af
	add	a,'0'
	ld	c,a
	call	PUTCH
	ret

; Display HL decimal, no trailing zeros or spaces

HLDEC::	push	hl
	push	de
	push	bc
	ld	b,0
	ld	de,-10000
	call	sbcnt
	ld	de,-1000
	call	sbcnt
	ld	de,-100
	call	sbcnt
	ld	de,-10
	call	sbcnt
	ld	a,l
	add	a,'0'
	ld	c,a
	call	PUTCH
	pop	bc
	pop	de
	pop	hl
	ret

sbcnt:	ld	C,'0'-1
sb1:	inc	c
	add	hl,de
	jr	c,sb1
	sbc	hl,de
	ld	a,b
	or	a
	jr	nz,PUTC
	ld	a,c
	cp	'0'
	ret	z
	ld	b,1
PUTC:	call	PUTCH
	ret

; Sleep for the specified number of ticks

SLEEP:	push	hl
	ld	hl,0
	ld	c,8
	SC	.MRKT
	pop	hl
	ret	c
	push	hl
	ld	e,8
	SC	.WTFLG
	pop	hl
	ret

;-----------------------------------------------------------------------

;!!	dseg

lbqio:	QIOW$	IO.RVB,1,9,iosb,<,,,,>
iosb:	ds	4
FDB:	ds	FINFSZ

ttqio:	QIOW$	IO.WLB,5,3,iosb,<BUF,,,,>
BUF:	ds	80	; terminal output buffer
BUFPTR:	ds	2
BUFCNT:	ds	1

TMPTDB:	db	'MCR...'
	db	0,0,0,0,0,0
	db	0,0,0,0,0,0
	dw	0
	db	0,0
	db	1,1
	db	'TT',0,'LB',0
	dw	0,0,0
	db	0,0
	dw	0,0,0,0
	dw	0,0

tdbadr:	ds	2	; address of user-supplied TDB in user space
hdr:	ds	256	; buffer for task header

	ds	128	; space for init stack
INISTK	equ	$

INIT_E	equ	$

	end	;INIT_S
