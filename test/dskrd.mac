	.z80

	include	SYSFN.INC
	include	ERRORS.INC
	include	QIO.INC

	extrn	PUTCH,PUTSTR,HLHEX,AHEX,CRLF,TTFLSH,EXIT
	extrn	QIOBLK,QIOSB

BLKNO	equ	13	;289

	cseg

;-----------------------------------------------------------------------

; Disk I/O read consistency test. Runs until disk read error occurs,
; or until aborted. Used to debug a rare floppy-missing-a-byte bug on
; the P112 (Z80182 DMA bug?).

; The problem apparently happens when a DMA request arrives while the
; Z182 is servicing an interrupt: the DMA request is missed or delayed,
; even when the DMA supposedly has higher priority. But then again, my
; P112 has an early Z182 chip with a number of bugs not present in the
; newer versions (e.g. missing ENH182 register, DMA disabled by HALT
; instruction, etc.)

START:	ld	sp,stack

	ld	de,'SY'
	ld	c,0
	ld	b,1
	SC	.ALUN

	ld	bc,BLKNO
	ld	de,refbuf
	call	DSKRD
	jr	c,rderr

loop:	ld	bc,BLKNO
	ld	de,buf
	call	DSKRD
	jr	c,rderr

	ld	a,10
	ld	(maxdif),a

	ld	hl,refbuf
	ld	de,buf
	ld	bc,512
comp:	ld	a,(de)
	cp	(hl)
	call	nz,report
	inc	hl
	inc	de
	dec	bc
	ld	a,b
	or	c
	jr	nz,comp

	jr	loop

rderr:	call	CRLF
	ld	hl,errmsg
	call	PUTSTR
	call	CRLF
	ld	hl,EX.ERR
	jp	EXIT

errmsg:	db	'Disk read error',0

report:	ld	a,(maxdif)
	or	a
	ret	z
	dec	a
	ld	(maxdif),a
	push	hl
	push	de
	ld	de,refbuf
	or	a
	sbc	hl,de
	call	HLHEX
	ld	c,':'
	call	PUTCH
	ld	c,' '
	call	PUTCH
	pop	de
	pop	hl
	ld	a,(hl)
	call	AHEX
	ld	c,' '
	call	PUTCH
	ld	a,(de)
	call	AHEX
	call	CRLF
	call	TTFLSH
	ret

;-----------------------------------------------------------------------

; Read block number in BC from LUN 1 to buffer in DE.

DSKRD:	push	ix
	ld	ix,QIOBLK
	ld	(ix+Q.FUNC),IO.RLB ; function code
	ld	(ix+Q.SUBF),0	; subfunction
	ld	(ix+Q.LUN),1	; use LUN 1
	ld	(ix+Q.BUF),e	; buffer address
	ld	(ix+Q.BUF+1),d
	ld	(ix+Q.BLK),c	; block number
	ld	(ix+Q.BLK+1),b
	ld	hl,512
	ld	(ix+Q.LEN),l
	ld	(ix+Q.LEN+1),h
	ld	(ix+Q.EFN),9	; flag number
	ld	(ix+Q.WAIT),1	; wait for completion
	ld	hl,QIOSB
	ld	(ix+Q.IOSB),l	; set result address
	ld	(ix+Q.IOSB+1),h
	inc	hl
	ld	(hl),0		; clear count of bytes read
	inc	hl
	ld	(hl),0
	push	ix
	pop	hl
	SC	.QIO		; .QIOW
	pop	ix
	ret	c		; if queueing failed
	ld	hl,(QIOSB+2)	; fetch byte count
	ld	a,(QIOSB)	; fetch return code
	or	a		; check result
	ret	z
	scf
	ret

;-----------------------------------------------------------------------

	dseg

refbuf:	ds	512
buf:	ds	512
maxdif:	ds	1

	ds	128		; stack space
stack	equ	$

	end	START
