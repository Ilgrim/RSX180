;**********************************************************************;
;                                                                      ;
;   MCR external command HELLO/HELP for RSX180.                        ;
;   Copyright (C) 2014-2019, Hector Peraza.                            ;
;                                                                      ;
;   This program is free software; you can redistribute it and/or      ;
;   modify it under the terms of the GNU General Public License as     ;
;   published by the Free Software Foundation; either version 2 of     ;
;   the License, or (at your option) any later version.                ;
;                                                                      ;
;   This program is distributed in the hope that it will be useful,    ;
;   but WITHOUT ANY WARRANTY; without even the implied warranty of     ;
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      ;
;   GNU General Public License for more details.                       ;
;                                                                      ;
;   You should have received a copy of the GNU General Public License  ;
;   along with this program; if not, write to the Free Software        ;
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.          ;
;                                                                      ;
;**********************************************************************;

	.Z80

	cseg

;	include	SYSCONF.INC
	include	SYSFN.INC
	include	DCB.INC
	include	TCB.INC
	include	LCB.INC
	include	FCB.INC
	include	QIO.INC
	include	ACNT.INC
	include	CLICB.INC
	include	ERRORS.INC
	include	SYSTEM.INC

CR	equ	0Dh
LF	equ	0Ah
TAB	equ	09h
ESC	equ	1Bh

LUN	equ	1

	extrn	CRLF,UCASE,GETLN,PUTCH,PUTSTR,TTFLSH,TTLUN
	extrn	GCCL,PFN,PERROR,BCD2BIN,AHEX,ADEC,ADEC2,HLDEC
	extrn	ATTACH,DETACH,MD5INI,MD5END,MD5UPD

KCALL	MACRO	addr
	call	SWSTK
	dw	addr
	ENDM

;-----------------------------------------------------------------------

START:	ld	sp,stack
	ld	hl,0
	ld	de,TSKTCB
	SC	.GTSK		; get task info
	call	GCCL		; get MCR command line
	ex	de,hl
	push	de
	call	skpnam
	ld	(lnptr),de
	pop	de
	ld	hl,exit
	push	hl		; push return address
	ld	hl,hlpnam
	ld	b,4
	call	nmatch
	jp	z,HELP
	jp	HELLO

exit:	ld	hl,EX.SUC
	SC	.EXIT

hlpnam:	db	'HELP'

;-----------------------------------------------------------------------

; Print error message in the form 'HEL -- message'

CMDERR:	ld	hl,snerr
ERROR:	push	hl
	ld	hl,eprfx
	call	PUTSTR
	pop	hl
	call	PUTSTR
	ld	c,CR
	call	PUTCH
	scf
	ret

SYSERR:	push	af
	ld	hl,eprfx
	call	PUTSTR
	pop	af
	call	PERROR
	ld	c,CR
	call	PUTCH
	scf
	ret

eprfx:	db	CR,LF,'HEL -- ',0
snerr:	db	'Syntax error',0

;-----------------------------------------------------------------------

; Copy string (HL) <- (DE)

cpstr:	ld	a,(de)
	or	a
	ret	z
	ld	(hl),a
	inc	hl
	inc	de
	jr	cpstr

; Copy string (HL) <- (DE), max B chars

cpnstr:	ld	a,(de)
	or	a
	ret	z
	ld	(hl),a
	inc	hl
	inc	de
	djnz	cpnstr
	ret

; Compare uppercase strings (HL) and (DE), max B chars

nmatch:	ld	a,(de)
	call	UCASE
	cp	(hl)
	ret	nz
	inc	hl
	inc	de
	djnz	nmatch
	ret

; Compare strings (HL) and (DE), max B chars

stncmp:	ld	a,(de)
	cp	(hl)
	ret	nz
	inc	hl
	inc	de
	djnz	stncmp
	ret

; Compute string (HL) length, return value in C.

strlen:	ld	c,0
strl1:	ld	a,(hl)
	or	a
	ret	z
	inc	hl
	inc	c
	jr	strl1

; Clear memory region. HL = address, BC = length.

clrmem:	ld	a,b
	or	c
	ret	z
	ld	e,l
	ld	d,h
	inc	de
	ld	(hl),0
	dec	bc
	ld	a,b
	or	c
	ret	z
	ldir
	ret

; Get command name (9 chars max) from input line into cmdnam.

getcmd:	ld	b,9
getn:	ld	de,(lnptr)
	ld	hl,cmdnam
	call	getns
	call	getnam
	ld	(lnptr),de
	ret

; Get a name (up to B bytes in length) into HL buffer.

getnam:	call	getfs
	jr	z,gn3
	call	UCASE
	ld	(hl),a
	inc	hl
	inc	de
	djnz	getnam
gn2:	call	getfs
	jr	z,gn3
	inc	de
	jr	gn2
gn3:	ld	(hl),0
	ret

; Pad name in (HL) with spaces, up to B in length.

padnam:	ld	a,(hl)
	or	a
	jr	z,pad
	inc	hl
	djnz	padnam
	ret
pad:	ld	(hl),' '
	inc	hl
	djnz	pad
	ret

; Get next non-blank char. Returns Z flag set on end of line.

skip:	inc	de
getns:	ld	a,(de)
	or	a
	ret	z
	call	isblnk
	jr	z,skip
	ret

; Get next char. Returns Z on end of line or if char is a delimiter.

getfs:	ld	a,(de)
	or	a
	ret	z
	cp	' '
	jr	c,gf1
	ret	z
	cp	'='
	ret	z
	cp	','
	ret	z
	cp	'/'
	ret	z
	ret
gf1:	xor	a
	ret

; Skip name

skpnam:	ld	a,(de)
	or	a
	ret	z
	call	isblnk
	jr	z,getns		; return via getns (skip spaces)
	inc	de
	jr	skpnam

; Check for blank character in A

isblnk:	or	a
	ret	z
	cp	' '
	ret	z
	cp	CR
	ret	z
	cp	LF
	ret	z
	cp	TAB
	ret

;-----------------------------------------------------------------------

; Print device name (HL = file info).

PDEVNM:	ld	bc,F.DEV
	add	hl,bc		; point to F.DEV
	ld	c,(hl)
	call	PUTCH
	inc	hl
	ld	c,(hl)
	call	PUTCH
	inc	hl
	ld	a,(hl)
	call	ADEC
	ld	c,':'
	call	PUTCH
	ret

; Print directory name (HL = file info), do not show the extension.

PDNAME:	ld	bc,F.NAME
	add	hl,bc		; point to F.NAME
pfn0:	ld	c,'['
	call	PUTCH
	ld	b,9
pfn1:	ld	a,(hl)
	cp	' '
	ld	c,a
	call	nz,pfn2
	inc	hl
	djnz	pfn1
	ld	c,']'
	call	PUTCH
	ret
pfn2:	call	PUTCH
	ret

PRDAT:	push	hl
	inc	hl
	inc	hl
	inc	hl
	ld	a,(hl)		; day
	call	AHEX
	ld	c,'-'
	call	PUTCH
	dec	hl
	ld	a,(hl)		; month
	call	BCD2BIN
	dec	a
	ld	c,a
	add	a,a		; *2
	add	a,c		; *3
	push	hl
	ld	hl,month
	ld	c,a
	ld	b,0
	add	hl,bc
	ld	b,3
pm:	ld	c,(hl)
	call	PUTCH
	inc	hl
	djnz	pm
	pop	hl
	ld	c,'-'
	call	PUTCH
	dec	hl
	dec	hl
	ld	a,(hl)		; year
	call	AHEX
	inc	hl
	ld	a,(hl)
	call	AHEX
	pop	hl
	ret

PRTIM:	push	hl
	inc	hl
	inc	hl
	inc	hl
	inc	hl
	ld	a,(hl)		; hour
	call	AHEX
	ld	c,':'
	call	PUTCH
	inc	hl
	ld	a,(hl)		; min
	call	AHEX
	ld	c,':'
	call	PUTCH
	inc	hl
	ld	a,(hl)		; sec
	call	AHEX
	pop	hl
	ret

month:	db	'JanFebMarAprMayJunJulAugSepOctNovDec'

; Validate date (only day and month)

valdt:	inc	hl
	inc	hl
	ld	c,12h+1		; month
	call	vldt1		; check if in range
	ret	c
	ld	c,31h+1		; day
vldt1:	ld	a,(hl)
	inc	hl
	or	a
	scf
	ret	z
	cp	c
	ccf
	ret

;-----------------------------------------------------------------------

; HELP [topic] [subtopic]

; 'topic' determines the help file to use: topic.HLP
; 'subtopic' determines the section within the help file.

; The start of each section is indicated by a backslash '\' on column 1
; followed by the subtopic name. Several names can be assigned to a single
; section by separating them with a vertical bar '|'. An asterisk '*' can
; be used inside a name to indicate that the charaters following it are
; optional, thus allowing partial searches.

; When searching for a subtopic, the first section that matches is
; displayed.

HELP:	ld	de,(lnptr)
	call	getns
	ld	hl,topic
	ld	b,9
	call	getnam		; get topic, if any

	call	getns		; skip spaces
	ld	hl,stopic
	ld	b,40
	call	getnam		; get subtopic, if any

	ld	hl,topic
	ld	a,(hl)
	or	a		; topic specified?
	ld	hl,dir		; if not, display SY0:[HELP]HELP.HLP and exit
	jr	z,hlp2

	ld	hl,dir
	ld	de,buf
	ld	bc,dirlen
	ldir			; copy directory prefix
	ld	hl,topic
	ld	b,9
hlp0:	ld	a,(hl)		; use topic as filename
	call	UCASE
	or	a
	jr	z,hlp1
	ld	(de),a
	inc	hl
	inc	de
	djnz	hlp0
hlp1:	ld	hl,ext		; add .HLP extension
	ld	bc,extlen
	ldir

	ld	hl,buf
hlp2:	call	OPENF		; open help file
	jp	c,errnt		; exit with error message if file not found
	ld	hl,0
	ld	(cnt),hl	; init char counter for readln

	ld	hl,stopic	; check subtopic
	ld	a,(hl)		; any specified?
	or	a
	jr	z,hlp4		; jump if not

hlp3:	call	readln		; else find it
	jr	c,errns		; exit with error message if not found
	ld	a,(hl)
	cp	'\'		; subtopic indicator?
	jr	nz,hlp3		; loop if not
	inc	hl
	ld	a,(hl)
	cp	';'		; comment?
	jr	z,hlp3		; ignore if yes
	call	smatch		; matches desired subtopic?
	jr	c,hlp3		; loop if not

hlp4:	ld	a,(TTLUN)
	ld	c,a
	ld	b,0		; no ASTs
	call	ATTACH		; attach to terminal

hlp5:	call	readln		; read line from file
	jr	c,hlp6		; end if end of file
	ld	a,(hl)
	cp	'\'		; start of next subtopic?
	jr	z,hlp6		; end if yes
	ld	c,LF
	call	PUTCH
	call	PUTSTR		; else print line
	ld	c,CR
	call	PUTCH
	jr	hlp5		; and loop for more

hlp6:	call	TTFLSH
	ld	a,(TTLUN)
	ld	c,a
	call	DETACH		; detach from terminal
	call	CLOSEF		; close help file
	ret			; and exit normally

errnt:	ld	hl,ntmsg	; 'topic not found'
	jr	errx

errns:	call	CLOSEF		; close help file
	ld	hl,nsmsg	; 'subtopic not found'
errx:	push	hl
	ld	hl,hpfx
	call	PUTSTR
	pop	hl
	call	PUTSTR		; print error message
	call	TTFLSH
	ld	hl,1
	ret			; and exit with error code 1 (TODO)

;-----------------------------------------------------------------------

; Read line from file

readln:	ld	hl,lnbuf
	ld	b,0
rdln1:	push	hl
	push	bc
	call	readch		; get char from file
	pop	bc
	pop	hl
	ret	c		; return if end of file
	cp	CR		; CR?
	jr	z,rdln1		; ignore it if yes
	cp	LF		; LF?
	jr	z,rdln2		; then we're done
	ld	c,a		; save char in C
	ld	a,b		; check char counter
	cp	128-1		; line buffer full?
	jr	nc,rdln1	; then ignore the rest of the line
	ld	(hl),c		; else store char in buffer
	inc	hl
	inc	b
	jr	rdln1		; loop for more
rdln2:	ld	(hl),0		; add a trailing zero
	ld	hl,lnbuf
	ret

readch:	ld	hl,(cnt)	; check counter of bytes read
	ld	a,h
	or	l
	jr	nz,rdch1	; jump if not zero
	ld	hl,buf		; else is time to refill the buffer
	ld	(ptr),hl	; reset pointer to begin of buffer
	call	FRBLK		; read next block from file
	ret	c
	ld	a,h
	or	l
	ld	a,E.EOF
	scf
	ret	z
rdch1:	dec	hl		; decrement counter of bytes read
	ld	(cnt),hl
	ld	hl,(ptr)
	ld	a,(hl)		; get character from buffer
	inc	hl		; advance pointer
	ld	(ptr),hl
	or	a
	ret

; Match subtopic

smatch:	ld	hl,lnbuf	; HL = line buffer
	ld	de,stopic	; DE = subtopic, already upper-cased
sm1:	ld	a,(hl)
	or	a		; end of line?
	scf
	ret	z		; return error, subtopic not found
	cp	'\'		; '\' is the subtopic indicator
	inc	hl
	jr	z,sm1		;  thus ignore it
	dec	hl
sm2:	push	de
	ld	b,1		; exact match by default
sm21:	ld	a,(hl)
	cp	'*'		; '*' means the chars following are optional
	jr	nz,sm22
	ld	b,0		; allow partial matches
	inc	hl
	ld	a,(hl)
	or	a		; end of line?
	jr	nz,sm21		; continue if not
	scf
	ret			; else return error, we have a bad help file
sm22:	ld	a,(de)		; get char from user-specified subtopic
	or	a
	jr	z,sm4		; we may have a match
	ld	c,a
	ld	a,(hl)
	cp	'|'		; '|' is used to separate synonyms
	jr	z,sm3
	call	UCASE
	cp	c
	jr	nz,sm3		; does not match this one
	inc	hl
	inc	de
	jr	sm21		; else loop to continue matching

sm3:	pop	de
sm31:	ld	a,(hl)
	inc	hl
	or	a		; end of line?
	scf
	ret	z		; return error, subtopic not found
	cp	'|'
	jr	nz,sm31		; else look for next synonym
	jr	sm2		; we got one

sm4:	pop	de
	ld	a,b
	or	a		; partial match allowed?
	ret	z		; return success if yes
	ld	a,(hl)
	or	a		; else check if all characters matched
	ret	z		; return success if yes
	cp	'|'
	ret	z
	scf			; else error, subtopic not found
	ret

hpfx:	db	CR,LF,'HELP -- ',0
ntmsg:	db	'Topic not found',CR,0
nsmsg:	db	'Subtopic not found',CR,0

dir:	db	'LB0:[HELP]'
dirlen	equ	$ - dir
dfname:	db	'HELP'
ext:	db	'.HLP',0
extlen	equ	$ - ext

;-----------------------------------------------------------------------

; LOGIN [username] or HELLO [username]

; - Finds username in account file
; - Sets logged-in bit of terminal session
; - Changes to user directory

; TODO:
; - Set login device from account file entry.
; - SYSLOGIN.CMD should be executed with terminal slaved and privileged,
;   to prevent user aborting it.
; - Allow g,u and g/u specification. Allow a slash at the end of the
;   name to suppress part of the LOGIN.TXT file (see below).
; - If user logged in using g/u or name/ form:
;   * if last login timestamp older than LOGIN.TXT timestamp or if
;        last login timestamp day older than todat, then display
;        full LOGIN.TXT file contents.
;   * else display LOGIN.TXT up the line starting with a '%'.

HELLO:	ld	hl,lcbbuf
	ld	c,I.USCB
	SC	.GIN
	jr	c,lgn1		; jump if no session found (not logged-in)

	ld	hl,logmse	; else error - already logged in
	jp	ERROR

lgn1:	ld	c,1
	SC	.SUPER		; enter supervisor mode
	jp	c,SYSERR
	call	GETDPR		; get CLI default prompt
	ld	a,(MFLAGS)	; get MCR flags
	push	af
	ld	c,0
	SC	.SUPER		; exit supervisor mode
	pop	af
	bit	0,a		; are logins enabled?
	jr	nz,lgn2		; jump if yes

	ld	hl,nlgtxt	; else type LB:[SYSTEM]NOLOGIN.TXT file
	call	TYPE		;  on terminal (if file exists)
	ld	hl,logdis	;   and exit with error message
	jp	ERROR

lgn2:	call	getcmd		; get user name after command
	ld	a,(cmdnam)
	or	a		; user name specified in login command?
	jr	nz,lgn3		; if yes, use it

	ld	bc,logprm	; else prompt for a name
	ld	hl,lnbuf
	ld	de,80		; D = 0 (read with echo), E = max length
	call	GETLN		; read with prompt
	ret	c
	call	stpeol		; strip eol
	ld	hl,lnbuf
	ld	(lnptr),hl
	call	getcmd		; get user name into cmdnam

lgn3:	ld	bc,pwdprm	; prompt for a password
	ld	hl,buf
	ld	d,1		; D = 1 (read without echo)
	ld	e,80		; E = max length
	call	GETLN		; read with prompt
	ret	c
	call	stpeol		; strip eol

	ld	hl,stopic	; use stopic as temp buffer
	ld	bc,16+8
	call	clrmem
	ld	de,buf
	ld	hl,stopic+8
	ld	b,16
	call	getns
	call	cpnstr
	ld	de,cmdnam
	ld	hl,stopic
	ld	b,8
	call	cpnstr
	call	MD5INI
	ld	hl,stopic
	ld	e,8+16
	call	MD5END		; compute password hash
	ld	(ptr),hl

	ld	hl,stopic
	ld	bc,8+16
	call	clrmem		; erase all traces of ASCII password
	ld	hl,buf
	ld	bc,80
	call	clrmem

	ld	de,cmdnam
	ld	hl,uname
	ld	b,9
	call	getnam		; get user name into 'uname' buffer

	ld	hl,actfil
	call	OPENF		; open account file
	jr	c,lgn8		; error if could not open file

lgn4:	call	ACNTR		; read account record
	jr	c,lgn7		; exit loop on EOF or error

	ld	hl,buf+AF.UNAM
	ld	de,uname
	ld	b,9
	call	nmatch		; compare user name
	jr	z,lgn5		; exit loop if match found

	call	ACNXT		; else try next record
	jr	lgn4

lgn5:	ld	hl,(ptr)
	ld	de,buf+AF.PWD
	ld	b,16
	call	stncmp		; compare passwords
	jr	nz,lgn6

	; valid account

	ld	hl,dtbuf
	push	hl
	SC	.GDAT
	pop	hl
	ld	de,buf+AF.LDT
	ld	bc,7
	ldir			; set last login date and time

	ld	hl,(buf+AF.LGNS)
	inc	hl		; increase login counter
	ld	(buf+AF.LGNS),hl

	xor	a
	ld	(buf+AF.LLF),a	; clear failed login counters
	ld	(buf+AF.LF10),a
	jr	lgn7

lgn6:	; failed attempt

	ld	hl,dtbuf
	push	hl
	SC	.GDAT
	pop	hl
	ld	de,buf+AF.LLA
	ld	bc,7
	ldir			; set last login attempt date and time

	ld	hl,(buf+AF.FAIL)
	inc	hl		; increase total login failures
	ld	(buf+AF.FAIL),hl

	ld	a,(buf+AF.LLF)	; increase failed login counters
	inc	a
	ld	(buf+AF.LLF),a
	ld	a,(buf+AF.LF10)
	inc	a
	ld	(buf+AF.LF10),a
	scf

lgn7:	push	af
	call	ACNTW		; update login record
	;jr	c,...
	call	CLOSEF
	pop	af
lgn8:	ld	hl,loginv
	jp	c,ERROR

	ld	a,(buf+AF.USR)
	ld	(usrid),a
	ld	a,(buf+AF.GRP)
	ld	(grpid),a

	ld	hl,cmdnam
	ld	b,9
	call	padnam

	ld	c,1
	SC	.SUPER
	jp	c,SYSERR
	ld	iy,cmdnam
	KCALL	LOGIN		; login
	jr	c,lgn9

	ld	de,'TI'
	ld	c,0
	ld	ix,(CTCB)
	KCALL	FNDDEV
;	jr	c,...		; should not fail...

	push	hl
	pop	ix
	ld	de,(buf+AF.SYD)
	ld	a,(buf+AF.SYD+2)
	ld	c,a		; DE-C = physical device name
	ld	hl,'SY'
	ld	b,0		; HL-B = logical device name
	ld	a,N.LGN
	KCALL	ASSIGN		; assign SY:

lgn9:	push	af
	ld	c,0
	SC	.SUPER
	pop	af
	jp	c,SYSERR

	; login succesful

	ld	hl,cmdnam
	ld	c,SD.TI
	SC	.SDIR		; set the user directory as current dir
	jp	c,SYSERR	; should not fail...

	ld	hl,cmdnam
	ld	c,SD.TSK
	SC	.SDIR		; set our current dir as well
	jp	c,SYSERR	; should not fail...

	ld	a,(grpid)
	ld	c,a
	call	STPRIV		; set terminal privileges

	ld	hl,logms1	; display system identification
	call	PUTSTR
	push	hl
	call	shver		; display system version
	pop	hl
	inc	hl
	call	PUTSTR
	push	hl
	ld	hl,hname
	push	hl
	ld	c,I.HOST
	SC	.GIN
	pop	hl
	jr	c,lgn10		; jump if host name not available
	push	hl
	ex	de,hl
	ld	hl,hname
	ld	b,9
	call	getnam		; trim host name
	pop	hl
	call	PUTSTR		; display host name
lgn10:	pop	hl
	inc	hl
	call	PUTSTR
	ld	hl,dtbuf
	call	PRDAT		; display login date
	ld	c,' '
	call	PUTCH
	call	PRTIM		; and time
	ld	hl,logms2	; 'logged on terminal ...'
	call	PUTSTR
	push	hl
	call	GETCON
	push	af
	ld	c,e
	call	PUTCH		; display terminal name
	ld	c,d
	call	PUTCH
	pop	af
	ld	l,a
	ld	h,0
	xor	a
	call	HLDEC
	ld	c,':'
	call	PUTCH
	pop	hl
	inc	hl
	call	PUTSTR		; ' as '
	ld	hl,uname
	call	PUTSTR		; display user name
	call	CRLF
	ld	hl,good		; 'good ... morning, evening, etc.'
	call	PUTSTR
	ld	a,(dtbuf+4)	; get hour
	call	chkhr		; greet accordingly
	call	PUTSTR
	call	CRLF
	call	TTFLSH

	ld	hl,logtxt
	call	TYPE		; display LB:[SYSTEM]LOGIN.TXT if it exists

	; check for system startup command file

	ld	hl,syscmd
	call	OPENF
	jr	c,lgn11		; system startup file not found
	call	CLOSEF

	ld	hl,PROMPT
	call	PUTSTR		; display CLI default prompt
	call	TTFLSH

	ld	hl,syscmd
	call	pretdb
	ld	hl,0
	ld	(exstat),hl
	ld	hl,mcrtdb
	ld	e,11		; flag number
	SC	.RQST
	jr	c,lgn11		; TODO: display error message?
	ld	e,11
	SC	.WTFLG		; wait until SYSLOGIN.CMD completes

lgn11:	; check for local startup command file

	ld	hl,inicmd
	call	OPENF
	ret	c		; startup file not found
	call	CLOSEF

	ld	hl,PROMPT
	call	PUTSTR		; display CLI default prompt
	call	TTFLSH

	ld	hl,inicmd
	call	pretdb
	ld	hl,mcrtdb
	SC	.RPOI		; request MCR and send command line
	jp	c,SYSERR
	ret

; Display system version

shver:	ld	c,I.VERS
	SC	.GIN
	ret	c
	ld	c,'V'
	call	PUTCH
	ld	a,h
	call	ADEC
	ld	c,'.'
	call	PUTCH
	ld	a,l
	call	ADEC2
	ret

; Strip End-Of-Line char from string @HL, BC = length

stpeol:	ld	a,b
	or	c
	ret	z
	push	hl
	add	hl,bc
	dec	hl
	ld	(hl),0
	pop	hl
	ret

; Prepare TDB to execute command file via MCR and echo the command on
; the terminal. Called with HL = cmd file name.

pretdb:	push	hl		; push ptr to command file name
	ld	hl,buf
	call	GETCON
	ld	(hl),e		; set device name and unit
	inc	hl
	ld	(hl),d
	inc	hl
	ld	(hl),a
	inc	hl
	xor	a
	ld	(hl),a		; clear OCB ptr
	inc	hl
	ld	(hl),a
	inc	hl
	pop	de		; pop ptr to command file name into DE
	push	hl		; remember start of command line
	ld	(hl),'@'
	inc	hl
	call	cpstr		; set filename
	ld	(hl),CR		; add command terminator
	inc	hl
	ld	(hl),0
	pop	hl		; pop start of command line
	push	hl
	call	PUTSTR		; echo command
	call	TTFLSH
	pop	hl
	call	strlen
	ld	a,5		; account for dev name, unit and OCB ptr
	add	a,c
	ld	e,a
	ld	d,0
	ld	hl,buf
	ld	(mcrtdb+TD.SDAT),hl
	ld	(mcrtdb+TD.SLEN),de
	ret

loginv:	db	'Invalid account',0
logmse:	db	'Other user logged in',0
logdis:	db	'Logins are disabled',0

logprm:	db	CR,LF,'User name: ',0
pwdprm:	db	CR,LF,'Password: ',0

logms1:	db	CR,LF,LF,'RSX180 ',0,' ',0,CR,LF,0
logms2:	db	' Logged on terminal ',0,' as ',0

chkhr:	cp	18h
	ld	hl,ge
	ret	nc
	cp	12h
	ld	hl,ga
	ret	nc
	ld	hl,gm
	ret

good:	db	CR,LF,'Good ',0
gm:	db	'Morning',0
ga:	db	'Afternoon',0
ge:	db	'Evening',0

erropn:	db	'Failed to open ',0

actfil:	db	'LB0:[SYSTEM]ACNT.DAT',0
logtxt:	db	'LB0:[SYSTEM]LOGIN.TXT',0
nlgtxt:	db	'LB0:[SYSTEM]NOLOGIN.TXT',0
syscmd:	db	'LB0:[SYSTEM]SYSLOGIN.CMD',0
inicmd:	db	'LOGIN.CMD',0

;-----------------------------------------------------------------------

; Display text file on terminal. Called with HL = filename.

TYPE:	call	OPENF		; parse filename and open help file
	ret	c		; return with CY set if file not found
	ld	hl,0
	ld	(cnt),hl	; init char counter for readln

	ld	a,(TTLUN)
	ld	c,a
	ld	b,0		; no ASTs
	call	ATTACH		; attach to terminal

typ1:	ld	c,CR
	call	PUTCH
	call	readln		; read line from file
	jr	c,typ2		; exit loop if end of file
	ld	c,LF
	call	PUTCH
	call	PUTSTR		; else print line
	jr	typ1		; and loop

typ2:	call	TTFLSH
	ld	a,(TTLUN)
	ld	c,a
	call	DETACH		; detach from terminal
	call	CLOSEF		; close help file
	ret			; and exit normally

;-----------------------------------------------------------------------

; Get terminal device name and unit into DE-A.

GETCON:	ld	de,(TSKTCB+T.CON)
	ld	a,(TSKTCB+T.CON+2)
	ret

; Get default MCR prompt. Called in supervisor mode.

GETDPR:	ld	de,(CLIST)	; TODO: get CLICB associated to terminal
	ld	a,d
	or	e		; valid CLICB?
	jr	nz,gdpr1	; jump if yes
	ld	hl,DPR
	ld	bc,DPRL
	jr	gdpr2		; else use the 'emergency' prompt
gdpr1:	ld	hl,CL.DPL
	add	hl,de
	ld	a,(hl)
	and	1Fh		; trim length just in case
	ld	c,a
	ld	b,0
	ld	hl,CL.DAT
	add	hl,de
gdpr2:	ld	de,PROMPT
	ldir
	ret

DPR:	db	CR,LF,'>',0	; 'emergency' prompt in case CLICB is not set
DPRL	equ	$-DPR

;-----------------------------------------------------------------------

; Set session privileged if Group ID < 10

STPRIV:	push	bc
	ld	c,1
	SC	.SUPER		; enter supervisor mode
	pop	bc
	ret	c
	push	bc
	call	GETCON
	ld	c,a
	ld	ix,(CTCB)
	KCALL	FNDDEV
	pop	bc
	jr	c,fnds2		; should not happen
	push	hl
	pop	ix
	ld	l,(ix+U.LCB)
	ld	h,(ix+U.LCB+1)
	ld	a,h
	or	l
	scf
	jr	z,fnds2		; should not happen
	push	hl
	pop	iy
	ld	a,c
	cp	10
	jr	c,fnds1
	res	LS.PRV,(iy+L.ST)
	jr	fnds2
fnds1:	set	LS.PRV,(iy+L.ST)
fnds2:	push	af
	ld	c,0
	SC	.SUPER
	pop	af
	ret

;-----------------------------------------------------------------------

; Parse file name, assign LUN and open file. HL = filename.

OPENF:	push	ix
	ld	ix,fdb
	call	PFN		; parse file name
	pop	ix
	ld	a,E.BADF
	ret	c
	ld	b,LUN
	ld	de,(fdb+F.DEV)
	ld	a,(fdb+F.UNIT)
	ld	c,a		; device name in DE-C
	SC	.ALUN		; assign LUN
	ret	c
	ld	hl,qio1
	SC	.QIO		; open file
	ret	c
	ld	hl,0
	ld	(blkno),hl
	ld	(offs),hl
	ld	a,(iosb)
	or	a
	ret	z
	scf
	ret

; Close file

CLOSEF:	ld	hl,qio4
	SC	.QIO
	ret	c
	ld	a,(iosb)
	or	a
	ret	z
	scf
	ret

; Read next block from file

FRBLK:	ld	hl,(blkno)
	ld	(qio2+Q.BLK),hl
	ld	hl,0
	ld	(qio2+Q.BLK+2),hl
	ld	(qio2+Q.OFS),hl
	ld	hl,512
	ld	(qio2+Q.LEN),hl
	ld	hl,qio2
	SC	.QIO
	ret	c
	ld	hl,(blkno)
	inc	hl
	ld	(blkno),hl
	ld	a,(iosb)
	or	a
	scf
	ret	nz
	ld	hl,(iosb+2)
	xor	a
	ret

; Read record from account file, does not advance file pointers.

ACNTR:	ld	hl,(blkno)
	ld	(qio2+Q.BLK),hl
	ld	hl,0
	ld	(qio2+Q.BLK+2),hl
	ld	hl,(offs)
	ld	(qio2+Q.OFS),hl
	ld	hl,AFSZ
	ld	(qio2+Q.LEN),hl
	ld	hl,qio2
	SC	.QIO
	ret	c
	ld	a,(iosb)
	or	a
	ret	z
	scf
	ret

; Write record to account file.

ACNTW:	ld	hl,(blkno)
	ld	(qio3+Q.BLK),hl
	ld	hl,0
	ld	(qio3+Q.BLK+2),hl
	ld	hl,(offs)
	ld	(qio3+Q.OFS),hl
	ld	hl,AFSZ
	ld	(qio3+Q.LEN),hl
	ld	hl,qio3
	SC	.QIO
	ret	c
	ld	a,(iosb)
	or	a
	ret	z
	scf
	ret

; Advance file pointers to next account record

ACNXT:	ld	hl,(offs)
	ld	de,AFSZ
	add	hl,de
	ld	(offs),hl
	ld	de,512
	or	a
	sbc	hl,de
	ret	c
	ld	(offs),hl
	ld	hl,(blkno)
	inc	hl
	ld	(blkno),hl
	or	a
	ret

;-----------------------------------------------------------------------

	dseg

TSKTCB:	ds	TCBSZ		; our TCB

mcrtdb:	db	'MCR...'	; task name
	db	0,0,0,0,0,0	; task id
	db	0,0,0,0,0,0	; partition
	dw	0		; address of command line block (not used)
	db	0,0,0,0		; pri, attr, user, grp (not used)
	db	'TI',0		; terminal device and unit (not used)
	db	'LB',0		; load device and unit (not used)
	dw	0,0,0		; starting block and size (not used)
	db	0,0		; bank and size (not used)
	dw	0,0,0,0		; start, end/incr, ept, init sp (not used)
	dw	0		; address of data block to send
	dw	0		; size of data block to send

exstat:	ds	2

lcbbuf:	ds	LCBSZ
fname:	ds	FNSZ
fdb:	ds	FDBSZ

PROMPT:	ds	32

dtbuf:	ds	8

lnptr:	ds	2
cmdnam:	ds	9		; ! do not !
usrid:	ds	1		; ! change !
grpid:	ds	1		; ! order  !
uname:	ds	10
hname:	ds	10

topic:	ds	10
stopic:	ds	41

afmode	equ	IO.ACC OR (SF.ACR OR SF.ACW OR SF.SHR) SHL 8

qio1:	QIOW$	afmode,LUN,9,iosb,<fdb>
qio2:	QIOW$	IO.RVB,LUN,9,iosb,<buf,512,0,0,>
qio3:	QIOW$	IO.WVB,LUN,9,iosb,<buf,512,0,0,>
qio4:	QIOW$	IO.DEA,LUN,9,iosb
iosb:	ds	4

lnbuf:	ds	128
cnt:	ds	2
ptr:	ds	2
blkno:	ds	2
offs:	ds	2
buf:	ds	512

	ds	256		; stack space
stack	equ	$

	end	START
