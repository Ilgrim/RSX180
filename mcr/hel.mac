;**********************************************************************;
;                                                                      ;
;   MCR external command HELLO/HELP for RSX180.                        ;
;   Copyright (C) 2014-2019, Hector Peraza.                            ;
;                                                                      ;
;   This program is free software; you can redistribute it and/or      ;
;   modify it under the terms of the GNU General Public License as     ;
;   published by the Free Software Foundation; either version 2 of     ;
;   the License, or (at your option) any later version.                ;
;                                                                      ;
;   This program is distributed in the hope that it will be useful,    ;
;   but WITHOUT ANY WARRANTY; without even the implied warranty of     ;
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      ;
;   GNU General Public License for more details.                       ;
;                                                                      ;
;   You should have received a copy of the GNU General Public License  ;
;   along with this program; if not, write to the Free Software        ;
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.          ;
;                                                                      ;
;**********************************************************************;

	.Z80

	cseg

;	include	SYSCONF.INC
	include	SYSFN.INC
	include	TCB.INC
	include	LCB.INC
	include	FCB.INC
	include	QIO.INC
	include	CLICB.INC
	include	ERRORS.INC
	include	SYSTEM.INC

CR	equ	0Dh
LF	equ	0Ah
TAB	equ	09h
ESC	equ	1Bh

LUN	equ	1

	extrn	CRLF,UCASE,GETLN,PUTCH,PUTSTR,TTFLSH,GCCL
	extrn	PFN,PDN,PERROR,BCD2BIN,AHEX,ADEC,ADEC2,HLDEC

KCALL	MACRO	addr
	call	SWSTK
	dw	addr
	ENDM

;-----------------------------------------------------------------------

START:	ld	sp,stack
	ld	hl,0
	ld	de,TSKTCB
	SC	.GTSK		; get task info
	call	GCCL		; get MCR command line
	ex	de,hl
	push	de
	call	skpnam
	ld	(lnptr),de
	pop	de
	ld	hl,exit
	push	hl		; push return address
	ld	hl,hlpnam
	ld	b,4
	call	nmatch
	jp	z,HELP
	jp	HELLO

exit:	ld	hl,EX.SUC
	SC	.EXIT

hlpnam:	db	'HELP'

;-----------------------------------------------------------------------

; Print error message in the form 'HEL -- message'

CMDERR:	ld	hl,snerr
ERROR:	push	hl
	ld	hl,eprfx
	call	PUTSTR
	pop	hl
	call	PUTSTR
	ld	c,CR
	call	PUTCH
	scf
	ret

SYSERR:	push	af
	ld	hl,eprfx
	call	PUTSTR
	pop	af
	call	PERROR
	ld	c,CR
	call	PUTCH
	scf
	ret

eprfx:	db	CR,LF,'HEL -- ',0
snerr:	db	'Syntax error',0

;-----------------------------------------------------------------------

; Copy string (HL) <- (DE)

cpstr:	ld	a,(de)
	or	a
	ret	z
	ld	(hl),a
	inc	hl
	inc	de
	jr	cpstr

; Compare strings (HL) and (DE), max B chars

nmatch:	ld	a,(de)
	call	UCASE
	cp	(hl)
	ret	nz
	inc	hl
	inc	de
	djnz	nmatch
	ret

; Compute string (HL) length, return value in C.

strlen:	ld	c,0
strl1:	ld	a,(hl)
	or	a
	ret	z
	inc	hl
	inc	c
	jr	strl1

; Get command name (9 chars max) from input line into cmdnam.

getcmd:	ld	b,9
getn:	ld	de,(lnptr)
	ld	hl,cmdnam
	call	getns
	call	getnam
	ld	(lnptr),de
	ret

; Get user name (9 chars) into cmdnam, padding with blanks if neccessary.

getun:	call	getcmd
fillsp:	inc	b
	dec	b
	ret	z
sfill:	ld	(hl),' '
	inc	hl
	djnz	sfill
	ret

; Get a name (up to B bytes in length) into HL buffer.

getnam:	call	getfs
	jr	z,gn3
	call	UCASE
	ld	(hl),a
	inc	hl
	inc	de
	djnz	getnam
gn2:	call	getfs
	jr	z,gn3
	inc	de
	jr	gn2
gn3:	ld	(hl),0
	ret

; Get next non-blank char. Returns Z flag set on end of line.

skip:	inc	de
getns:	ld	a,(de)
	or	a
	ret	z
	call	isblnk
	jr	z,skip
	ret

; Get next char. Returns Z on end of line or if char is a delimiter.

getfs:	ld	a,(de)
	or	a
	ret	z
	cp	' '
	jr	c,gf1
	ret	z
	cp	'='
	ret	z
	cp	','
	ret	z
	cp	'/'
	ret	z
	ret
gf1:	xor	a
	ret

; Skip name

skpnam:	ld	a,(de)
	or	a
	ret	z
	call	isblnk
	jr	z,getns		; return via getns (skip spaces)
	inc	de
	jr	skpnam

; Check for blank character in A

isblnk:	or	a
	ret	z
	cp	' '
	ret	z
	cp	CR
	ret	z
	cp	LF
	ret	z
	cp	TAB
	ret

;-----------------------------------------------------------------------

; Print device name (HL = file info).

PDEVNM:	ld	bc,F.DEV
	add	hl,bc		; point to F.DEV
	ld	c,(hl)
	call	PUTCH
	inc	hl
	ld	c,(hl)
	call	PUTCH
	inc	hl
	ld	a,(hl)
	call	ADEC
	ld	c,':'
	call	PUTCH
	ret

; Print directory name (HL = file info), do not show the extension.

PDNAME:	ld	bc,F.NAME
	add	hl,bc		; point to F.NAME
pfn0:	ld	c,'['
	call	PUTCH
	ld	b,9
pfn1:	ld	a,(hl)
	cp	' '
	ld	c,a
	call	nz,pfn2
	inc	hl
	djnz	pfn1
	ld	c,']'
	call	PUTCH
	ret
pfn2:	call	PUTCH
	ret

PRDAT:	push	hl
	inc	hl
	inc	hl
	inc	hl
	ld	a,(hl)		; day
	call	AHEX
	ld	c,'-'
	call	PUTCH
	dec	hl
	ld	a,(hl)		; month
	call	BCD2BIN
	dec	a
	ld	c,a
	add	a,a		; *2
	add	a,c		; *3
	push	hl
	ld	hl,month
	ld	c,a
	ld	b,0
	add	hl,bc
	ld	b,3
pm:	ld	c,(hl)
	call	PUTCH
	inc	hl
	djnz	pm
	pop	hl
	ld	c,'-'
	call	PUTCH
	dec	hl
	dec	hl
	ld	a,(hl)		; year
	call	AHEX
	inc	hl
	ld	a,(hl)
	call	AHEX
	pop	hl
	ret

PRTIM:	push	hl
	inc	hl
	inc	hl
	inc	hl
	inc	hl
	ld	a,(hl)		; hour
	call	AHEX
	ld	c,':'
	call	PUTCH
	inc	hl
	ld	a,(hl)		; min
	call	AHEX
	ld	c,':'
	call	PUTCH
	inc	hl
	ld	a,(hl)		; sec
	call	AHEX
	pop	hl
	ret

month:	db	'JanFebMarAprMayJunJulAugSepOctNovDec'

; Validate date (only day and month)

valdt:	inc	hl
	inc	hl
	ld	c,12h+1		; month
	call	vldt1		; check if in range
	ret	c
	ld	c,31h+1		; day
vldt1:	ld	a,(hl)
	inc	hl
	or	a
	scf
	ret	z
	cp	c
	ccf
	ret

;-----------------------------------------------------------------------

; HELP [topic] [subtopic]

; 'topic' determines the help file to use: topic.HLP
; 'subtopic' determines the section within the help file.

; The start of each section is indicated by a backslash '\' on column 1
; followed by the subtopic name. Several names can be assigned to a single
; section by separating them with a vertical bar '|'. An asterisk '*' can
; be used inside a name to indicate that the charaters following it are
; optional, thus allowing partial searches.

; When searching for a subtopic, the first section that matches is
; displayed.

HELP:	ld	de,(lnptr)
	call	getns
	ld	hl,topic
	ld	b,9
	call	getnam		; get topic, if any

	call	getns		; skip spaces
	ld	hl,stopic
	ld	b,40
	call	getnam		; get subtopic, if any

	ld	hl,topic
	ld	a,(hl)
	or	a		; topic specified?
	ld	hl,dir		; if not, display SY0:[HELP]HELP.HLP and exit
	jr	z,hlp2

	ld	hl,dir
	ld	de,buf
	ld	bc,dirlen
	ldir			; copy directory prefix
	ld	hl,topic
	ld	b,9
hlp0:	ld	a,(hl)		; use topic as filename
	call	UCASE
	or	a
	jr	z,hlp1
	ld	(de),a
	inc	hl
	inc	de
	djnz	hlp0
hlp1:	ld	hl,ext		; add .HLP extension
	ld	bc,extlen
	ldir

	ld	hl,buf
hlp2:	call	OPENF		; open help file
	jp	c,errnt		; exit with error message if file not found
	ld	hl,0
	ld	(cnt),hl	; init char counter for readln

	ld	hl,stopic	; check subtopic
	ld	a,(hl)		; any specified?
	or	a
	jr	z,hlp4		; jump if not

hlp3:	call	readln		; else find it
	jr	c,errns		; exit with error message if not found
	ld	a,(hl)
	cp	'\'		; subtopic indicator?
	jr	nz,hlp3		; loop if not
	inc	hl
	ld	a,(hl)
	cp	';'		; comment?
	jr	z,hlp3		; ignore if yes
	call	smatch		; matches desired subtopic?
	jr	c,hlp3		; loop if not

hlp4:	call	readln		; read line from file
	jr	c,hlp5		; end if end of file
	ld	a,(hl)
	cp	'\'		; start of next subtopic?
	jr	z,hlp5		; end if yes
	ld	c,LF
	call	PUTCH
	call	PUTSTR		; else print line
	ld	c,CR
	call	PUTCH
	jr	hlp4		; and loop for more

hlp5:	call	TTFLSH
	call	CLOSEF		; close help file
	ret			; and exit normally

errnt:	ld	hl,ntmsg	; 'topic not found'
	jr	errx

errns:	call	CLOSEF		; close help file
	ld	hl,nsmsg	; 'subtopic not found'
errx:	push	hl
	ld	hl,hpfx
	call	PUTSTR
	pop	hl
	call	PUTSTR		; print error message
	call	TTFLSH
	ld	hl,1
	ret			; and exit with error code 1 (TODO)

;-----------------------------------------------------------------------

; Read line from file

readln:	ld	hl,lnbuf
	ld	b,0
rdln1:	push	hl
	push	bc
	call	readch		; get char from file
	pop	bc
	pop	hl
	ret	c		; return if end of file
	cp	CR		; CR?
	jr	z,rdln1		; ignore it if yes
	cp	LF		; LF?
	jr	z,rdln2		; then we're done
	ld	c,a		; save char in C
	ld	a,b		; check char counter
	cp	128-1		; line buffer full?
	jr	nc,rdln1	; then ignore the rest of the line
	ld	(hl),c		; else store char in buffer
	inc	hl
	inc	b
	jr	rdln1		; loop for more
rdln2:	ld	(hl),0		; add a trailing zero
	ld	hl,lnbuf
	ret

readch:	ld	hl,(cnt)	; check counter of bytes read
	ld	a,h
	or	l
	jr	nz,rdch1	; jump if not zero
	ld	hl,buf		; else is time to refill the buffer
	ld	(ptr),hl	; reset pointer to begin of buffer
	call	FRBLK		; read next block from file
	ret	c
	ld	a,h
	or	l
	ld	a,E.EOF
	scf
	ret	z
rdch1:	dec	hl		; decrement counter of bytes read
	ld	(cnt),hl
	ld	hl,(ptr)
	ld	a,(hl)		; get character from buffer
	inc	hl		; advance pointer
	ld	(ptr),hl
	or	a
	ret

; Match subtopic

smatch:	ld	hl,lnbuf	; HL = line buffer
	ld	de,stopic	; DE = subtopic, already upper-cased
sm1:	ld	a,(hl)
	or	a		; end of line?
	scf
	ret	z		; return error, subtopic not found
	cp	'\'		; '\' is the subtopic indicator
	inc	hl
	jr	z,sm1		;  thus ignore it
	dec	hl
sm2:	push	de
	ld	b,1		; exact match by default
sm21:	ld	a,(hl)
	cp	'*'		; '*' means the chars following are optional
	jr	nz,sm22
	ld	b,0		; allow partial matches
	inc	hl
	ld	a,(hl)
	or	a		; end of line?
	jr	nz,sm21		; continue if not
	scf
	ret			; else return error, we have a bad help file
sm22:	ld	a,(de)		; get char from user-specified subtopic
	or	a
	jr	z,sm4		; we may have a match
	ld	c,a
	ld	a,(hl)
	cp	'|'		; '|' is used to separate synonyms
	jr	z,sm3
	call	UCASE
	cp	c
	jr	nz,sm3		; does not match this one
	inc	hl
	inc	de
	jr	sm21		; else loop to continue matching

sm3:	pop	de
sm31:	ld	a,(hl)
	inc	hl
	or	a		; end of line?
	scf
	ret	z		; return error, subtopic not found
	cp	'|'
	jr	nz,sm31		; else look for next synonym
	jr	sm2		; we got one

sm4:	pop	de
	ld	a,b
	or	a		; partial match allowed?
	ret	z		; return success if yes
	ld	a,(hl)
	or	a		; else check if all characters matched
	ret	z		; return success if yes
	cp	'|'
	ret	z
	scf			; else error, subtopic not found
	ret

hpfx:	db	CR,LF,'HELP -- ',0
ntmsg:	db	'Topic not found',CR,0
nsmsg:	db	'Subtopic not found',CR,0

dir:	db	'LB0:[HELP]'
dirlen	equ	$ - dir
dfname:	db	'HELP'
ext:	db	'.HLP',0
extlen	equ	$ - ext

;-----------------------------------------------------------------------

; LOGIN [username] or HELLO [username]

; - Ensures that user directory exists (since we do not have an account
;   file)
; - Sets logged-in bit on terminal session
; - Changes to user directory

; TODO:
; - How to define a login device? Right now it defaults to the
;   current SY: assignment, but it should be the other way around...
;   (e.g. via account file)
; - SYSLOGIN.CMD should be executed with terminal slaved and privileged,
;   to prevent user aborting it.
; - If using an account file, implement the '%' feature of LOGIN.TXT.
; - Allow g,u specification? (would need a MASTER directory lookup, or
;   account file lookup).

HELLO:	ld	hl,lcbbuf
	ld	c,I.USCB
	SC	.GIN
	jr	c,lgn1		; jump if no session found

	ld	ix,lcbbuf
	bit	LS.LOG,(ix+L.ST); logged-in?
	jr	z,lgn1		; jump if not
	ld	hl,logmse	; else error - already logged in
	jp	ERROR

lgn1:	ld	c,1
	SC	.SUPER		; enter supervisor mode
	jp	c,SYSERR
	call	GETDPR		; get CLI default prompt
	ld	a,(MFLAGS)	; get MCR flags
	push	af
	ld	c,0
	SC	.SUPER		; exit supervisor mode
	pop	af
	bit	0,a		; are logins enabled?
	jr	nz,lgn2		; jump if yes

	ld	hl,nlgtxt	; else type LB:[SYSTEM]NOLOGIN.TXT file
	call	TYPE		;  on terminal (if file exists)
	ld	hl,logdis	;   and exit with error message
	jp	ERROR

lgn2:	call	getun		; get user name after command
	ld	a,(cmdnam)
	cp	' '		; user name specified in login command?
	jr	nz,lgn3		; if yes, use it

	ld	bc,logprm	; else prompt for a name
	ld	hl,lnbuf
	ld	de,80		; D = 0 (read with echo), E = max length
	call	GETLN		; read with prompt
	call	stpeol		; strip eol

	ld	hl,lnbuf
	ld	(lnptr),hl
	call	getun		; get user name into cmdnam

lgn3:	ld	hl,cmdnam
	ld	de,uname
	call	GETN9		; get user name into 'uname' buffer

	ld	hl,fname
	ld	de,mdir
	call	cpstr
	ld	de,uname
	call	cpstr
	ld	(hl),0
	ld	de,dirext
	call	addext

	ld	hl,fname
	call	OPENF		; try to open the user directory
	ld	hl,loginv
	jp	c,ERROR		; error if it does not exist (no such user)

	call	RDATTR		; read file attributes

	push	af
	call	CLOSEF
	pop	af
	jp	c,ERROR		; error if failed to read attributes

	ld	a,(finfo+F.ATTR)
	and	FA.DIR
	ld	hl,loginv
	jp	z,ERROR		; error if file is not a directory

	ld	a,(finfo+F.USER)
	ld	(usrid),a
	ld	a,(finfo+F.GROUP)
	ld	(grpid),a

	ld	c,1
	SC	.SUPER
	jp	c,SYSERR
	call	GETCON		; get console device name into DE-A
	ld	c,a		; now in DE-C
	ld	hl,cmdnam
	KCALL	LOGIN		; login
	push	af
	ld	c,0
	SC	.SUPER
	pop	af
	jp	c,SYSERR

	; login succesful

	ld	hl,uname	; fname
	ld	ix,fdb
	call	PFN		; parse into FDB
	ld	a,E.BADF
	jp	c,SYSERR
	ld	hl,fdb+F.NAME
	SC	.SDIR		; set the user directory as current dir
	jp	c,SYSERR	; should not fail...

	ld	a,(finfo+F.GROUP)
	ld	c,a
	call	STPRIV		; set terminal privileges

	ld	hl,logms1	; display system identification
	call	PUTSTR
	push	hl
	call	shver		; display system version
	pop	hl
	inc	hl
	call	PUTSTR
	push	hl
	ld	hl,hname
	push	hl
	ld	c,I.HOST
	SC	.GIN
	pop	hl
	jr	c,lgn4		; jump if host name not available
	push	hl
	ld	de,hname
	call	GETN9		; trim host name
	pop	hl
	call	PUTSTR		; display host name
lgn4:	pop	hl
	inc	hl
	call	PUTSTR
	ld	hl,dtbuf
	push	hl
	SC	.GDAT
	pop	hl
	call	PRDAT		; display date
	ld	c,' '
	call	PUTCH
	call	PRTIM		; display time
	ld	hl,logms2	; 'logged on terminal ...'
	call	PUTSTR
	push	hl
	call	GETCON
	push	af
	ld	c,e
	call	PUTCH		; display terminal name
	ld	c,d
	call	PUTCH
	pop	af
	ld	l,a
	ld	h,0
	xor	a
	call	HLDEC
	ld	c,':'
	call	PUTCH
	pop	hl
	inc	hl
	call	PUTSTR		; ' as '
	ld	hl,uname
	call	PUTSTR		; display user name
	call	CRLF
	ld	hl,good		; 'good ... morning, evening, etc.'
	call	PUTSTR
	ld	a,(dtbuf+4)	; get hour
	call	chkhr		; greet accordingly
	call	PUTSTR
	call	CRLF
	call	TTFLSH

	ld	hl,logtxt
	call	TYPE		; display LB:[SYSTEM]LOGIN.TXT if it exists

	; check for system startup command file

	ld	hl,syscmd
	call	OPENF
	jr	c,lgn5		; system startup file not found
	call	CLOSEF

	ld	hl,PROMPT
	call	PUTSTR		; display CLI default prompt
	call	TTFLSH

	ld	hl,syscmd
	call	pretdb
	ld	hl,0
	ld	(exstat),hl
	ld	hl,MCRTDB
	ld	e,11		; flag number
	SC	.RQST
	jr	c,lgn5		; TODO: display error message?
	ld	e,11
	SC	.WTFLG		; wait until SYSLOGIN.CMD completes

lgn5:	; check for local startup command file

	ld	hl,inicmd
	call	OPENF
	ret	c		; startup file not found
	call	CLOSEF

	ld	hl,PROMPT
	call	PUTSTR		; display CLI default prompt
	call	TTFLSH

	ld	hl,inicmd
	call	pretdb
	ld	hl,MCRTDB
	SC	.RPOI		; request MCR and send command line
	jp	c,SYSERR
	ret

; Display system version

shver:	ld	c,I.VERS
	SC	.GIN
	ret	c
	ld	c,'V'
	call	PUTCH
	ld	a,h
	call	ADEC
	ld	c,'.'
	call	PUTCH
	ld	a,l
	call	ADEC2
	ret

; Add file extension if none was originally specified

addext:	ld	hl,fname
ade0:	ld	a,(hl)
	cp	'.'
	ret	z
	or	a
	jr	z,ade1
	inc	hl
	jr	ade0
ade1:	ld	(hl),'.'
	inc	hl
	ex	de,hl
	ld	bc,3
	ldir
	ex	de,hl
	ld	(hl),0
	ret

; Strip End-Of-Line char from string @HL, BC = length

stpeol:	ld	a,b
	or	c
	ret	z
	push	hl
	add	hl,bc
	dec	hl
	ld	(hl),0
	pop	hl
	ret

; Get user name @HL (9 chars max) into buffer @DE

GETN9:	ld	b,9
	ld	c,0
gtn1:	ld	a,(hl)
	cp	' '
	jr	z,gtn2
	ld	(de),a
	inc	de
	inc	hl
	inc	c
	djnz	gtn1
gtn2:	xor	a
	ld	(de),a		; end with a null terminator
	ret

; Prepare TDB to execute command file via MCR and echo the command on
; the terminal. Called with HL = cmd file name.

pretdb:	push	hl		; push ptr to command file name
	ld	hl,buf
	call	GETCON
	ld	(hl),e		; set device name and unit
	inc	hl
	ld	(hl),d
	inc	hl
	ld	(hl),a
	inc	hl
	xor	a
	ld	(hl),a		; clear OCB ptr
	inc	hl
	ld	(hl),a
	inc	hl
	pop	de		; pop ptr to command file name into DE
	push	hl		; remember start of command line
	ld	(hl),'@'
	inc	hl
	call	cpstr		; set filename
	ld	(hl),CR		; add command terminator
	inc	hl
	ld	(hl),0
	pop	hl		; pop start of command line
	push	hl
	call	PUTSTR		; echo command
	call	TTFLSH
	pop	hl
	call	strlen
	ld	a,5		; account for dev name, unit and OCB ptr
	add	a,c
	ld	e,a
	ld	d,0
	ld	hl,buf
	ld	(mcrtdb+TD.SDAT),hl
	ld	(mcrtdb+TD.SLEN),de
	ret

mdir:	db	'SY0:[MASTER]',0

dirext:	db	'DIR'

loginv:	db	'Invalid user name',0
logpwd:	db	'Invalid password',0
logmse:	db	'Other user logged in',0
logdis:	db	'Logins are disabled',0

logprm:	db	CR,LF,'User name: ',0

logms1:	db	CR,LF,LF,'RSX180 ',0,' ',0,CR,LF,0
logms2:	db	' Logged on terminal ',0,' as ',0

chkhr:	cp	18h
	ld	hl,ge
	ret	nc
	cp	12h
	ld	hl,ga
	ret	nc
	ld	hl,gm
	ret

good:	db	CR,LF,'Good ',0
gm:	db	'Morning',0
ga:	db	'Afternoon',0
ge:	db	'Evening',0

erropn:	db	'Failed to open ',0

logtxt:	db	'LB0:[SYSTEM]LOGIN.TXT',0
nlgtxt:	db	'LB0:[SYSTEM]NOLOGIN.TXT',0

syscmd:	db	'LB0:[SYSTEM]SYSLOGIN.CMD',0

inicmd:	db	'LOGIN.CMD',0

;-----------------------------------------------------------------------

; Display text file on terminal. Called with HL = filename.

TYPE:	call	OPENF		; parse filename and open help file
	ret	c		; return with CY set if file not found
	ld	hl,0
	ld	(cnt),hl	; init char counter for readln

typ1:	ld	c,CR
	call	PUTCH
	call	readln		; read line from file
	jr	c,typ2		; exit loop if end of file
	ld	c,LF
	call	PUTCH
	call	PUTSTR		; else print line
	jr	typ1		; and loop

typ2:	call	TTFLSH
	call	CLOSEF		; close help file
	ret			; and exit normally

;-----------------------------------------------------------------------

; Get terminal device name and unit.

GETCON:	ld	de,(TSKTCB+T.CON)
	ld	a,(TSKTCB+T.CON+2)
	ret

; Get default MCR prompt. Called in supervisor mode.

GETDPR:	ld	de,(CLILST)	; TODO: get CLICB associated to terminal
	ld	a,d
	or	e		; valid CLICB?
	jr	nz,gdpr1	; jump if yes
	ld	hl,DPR
	ld	bc,DPRL
	jr	gdpr2		; else use the 'emergency' prompt
gdpr1:	ld	hl,CL.DPL
	add	hl,de
	ld	a,(hl)
	and	1Fh		; trim length just in case
	ld	c,a
	ld	b,0
	ld	hl,CL.DAT
	add	hl,de
gdpr2:	ld	de,PROMPT
	ldir
	ret

DPR:	db	CR,LF,'>',0	; 'emergency' prompt in case CLICB is not set
DPRL	equ	$-DPR

;-----------------------------------------------------------------------

; Set session privileged if Group ID < 10

STPRIV:	push	bc
	ld	c,1
	SC	.SUPER		; enter supervisor mode
	pop	bc
	ret	c
fndses:	ld	hl,(LCBLST)
fnds1:	ld	a,h
	or	l
	scf
	jr	z,fnds4
	push	hl
	pop	iy
	push	bc
	call	cmpdvn
	pop	bc
	jr	z,fnds2
	ld	l,(iy+L.LNK)
	ld	h,(iy+L.LNK+1)
	jr	fnds1
fnds2:	ld	a,c
	cp	10
	jr	c,fnds3
	res	LS.PRV,(iy+L.ST)
	jr	fnds4
fnds3:	set	LS.PRV,(iy+L.ST)
fnds4:	push	af
	ld	c,0
	SC	.SUPER
	pop	af
	ret

cmpdvn:	call	GETCON
	ld	c,a
	ld	a,(iy+L.CON)
	cp	e
	scf
	ret	nz
	ld	a,(iy+L.CON+1)
	cp	d
	scf
	ret	nz
	ld	a,(iy+L.CON+2)
	cp	c
	ret	z
	scf
	ret

;-----------------------------------------------------------------------

; Parse file name, assign LUN and open file. HL = filename.

OPENF:	push	ix
	ld	ix,fdb
	call	PFN		; parse file name
	pop	ix
	ld	a,E.BADF
	ret	c
	ld	b,LUN
	ld	de,(fdb+F.DEV)
	ld	a,(fdb+F.UNIT)
	ld	c,a		; device name in DE-C
	SC	.ALUN		; assign LUN
	ret	c
	ld	hl,qio1
	SC	.QIO		; open file
	ret	c
	ld	hl,0
	ld	(blkno),hl
	ld	a,(iosb)
	or	a
	ret	z
	scf
	ret

; Read file attributes

RDATTR:	ld	hl,qio2
	SC	.QIO
	ret	c
	ld	a,(iosb)
	or	a
	ret	z
	scf
	ret

; Close file

CLOSEF:	ld	hl,qio4
	SC	.QIO
	ret	c
	ld	a,(iosb)
	or	a
	ret	z
	scf
	ret

; Read next block from file

FRBLK:	ld	hl,(blkno)
	ld	(qio3+Q.BLK),hl
	ld	hl,qio3
	SC	.QIO
	ret	c
	ld	hl,(blkno)
	inc	hl
	ld	(blkno),hl
	ld	a,(iosb)
	or	a
	scf
	ret	nz
	ld	hl,(iosb+2)
	xor	a
	ret

;-----------------------------------------------------------------------

	dseg

TSKTCB:	ds	TCBSZ		; our TCB

mcrtdb:	db	'MCR...'	; task name
	db	0,0,0,0,0,0	; task id
	dw	0		; address of command line block (not used)
	db	0,0,0,0		; pri, attr, user, grp (not used)
	db	'TI',0		; terminal device and unit (not used)
	db	'LB',0		; load device and unit (not used)
	dw	0,0,0		; starting block and size (not used)
	dw	0		; LCB address (not used)
	db	0,0		; bank and size (not used)
	dw	0,0,0,0		; start, end/incr, ept, init sp (not used)
	dw	0		; address of data block to send
	dw	0		; size of data block to send

exstat:	ds	2

lcbbuf:	ds	LCBSZ
finfo:	ds	FINFSZ
fname:	ds	FNSZ
fdb:	ds	FDBSZ

PROMPT:	ds	32

dtbuf:	ds	8

lnptr:	ds	2
cmdnam:	ds	9		; ! do not !
usrid:	ds	1		; ! change !
grpid:	ds	1		; ! order  !
uname:	ds	10
hname:	ds	10

topic:	ds	10
stopic:	ds	41

qio1:	QIOW$	<<IO.ACC OR ((SF.ACR OR SF.SHR) SHL 8)>>,LUN,9,iosb,<fdb>
qio2:	QIOW$	IO.RAT,LUN,9,iosb,<finfo,FINFSZ>
qio3:	QIOW$	IO.RVB,LUN,9,iosb,<buf,512,0,0,>
qio4:	QIOW$	IO.DEA,LUN,9,iosb
iosb:	ds	4

lnbuf:	ds	128
cnt:	ds	2
ptr:	ds	2
blkno:	ds	2
buf:	ds	512

	ds	256		; stack space
stack	equ	$

	end	START
