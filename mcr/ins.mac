;**********************************************************************;
;                                                                      ;
;   MCR external command INS for RSX180.                               ;
;   Copyright (C) 2015-2019, Hector Peraza.                            ;
;                                                                      ;
;   This program is free software; you can redistribute it and/or      ;
;   modify it under the terms of the GNU General Public License as     ;
;   published by the Free Software Foundation; either version 2 of     ;
;   the License, or (at your option) any later version.                ;
;                                                                      ;
;   This program is distributed in the hope that it will be useful,    ;
;   but WITHOUT ANY WARRANTY; without even the implied warranty of     ;
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      ;
;   GNU General Public License for more details.                       ;
;                                                                      ;
;   You should have received a copy of the GNU General Public License  ;
;   along with this program; if not, write to the Free Software        ;
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.          ;
;                                                                      ;
;**********************************************************************;

	.Z80

	cseg

	include	SYSFN.INC
	include	QIO.INC
	include	LCB.INC
	include	THDR.INC
	include	SYSTEM.INC
	include	TCB.INC
	include	FCB.INC
	include	ERRORS.INC

CR	equ	0Dh
LF	equ	0Ah
TAB	equ	09h
ESC	equ	1Bh

	extrn	PFN,PDN,PERROR,CRLF,UCASE,PUTCH,PUTSTR,TTFLSH,GCCL

; INS <filename>[/INC=nnnn][/RUN[=REM]][/CLI=YES][/PRI=<n>][/TASK=<name>]
;               [/TERM=<ttn>][/ACP=YES]

; INS alone does not give a INS> prompt, neither it accepts an indirect
; command file. In both cases it produces a 'INS -- Syntax error' message.

; INS is a privileged task that maps onto the kernel and calls kernel
; routines. It also modifies the STD directly.

; TODO: check user privileges:
; - Refuse to install and run a privileged task (via MCR RUN command)
;   if terminal/user is not privileged.

;-----------------------------------------------------------------------

START:	ld	sp,stack	; do not use the default stack set up
				; by the task manager
	ld	hl,0
	ld	de,TSKTCB
	SC	.GTSK
	call	GCCL		; get MCR command line
	ex	de,hl
	call	skpnam
	ex	de,hl
	ld	(lnptr),hl
	call	doins
	ld	hl,EX.SUC
	SC	.EXIT

;-----------------------------------------------------------------------

; Print error message in the form 'INS -- message'

CMDERR:	ld	hl,snerr
	push	hl
	ld	hl,eprfx
	call	PUTSTR
	pop	hl
	call	PUTSTR
	ld	c,CR
	call	PUTCH
	ret

SYSERR:	push	af
	ld	hl,eprfx
	call	PUTSTR
	pop	af
	call	PERROR
	ld	c,CR
	call	PUTCH
	ret

eprfx:	db	CR,LF,'INS -- ',0
snerr:	db	'Syntax error',0

;-----------------------------------------------------------------------

; Copy string (HL) <- (DE)

cpstr:	ld	a,(de)
	or	a
	ret	z
	ld	(hl),a
	inc	hl
	inc	de
	jr	cpstr

; Get command name (9 chars max) from input line into cmdnam.

getcmd:	ld	de,(lnptr)
	ld	hl,cmdnam
	ld	b,9
	call	getns
	call	getnam
	ld	(lnptr),de
	ret

; Get task name (9 chars) into cmdnam, padding with blanks if neccessary.

getn9:	call	getcmd
	inc	b
	dec	b
	ret	z
sfill:	ld	(hl),' '
	inc	hl
	djnz	sfill
	ret

; Get a name (up to B bytes in length) into HL buffer.

getnam:	call	getfs
	jr	z,gn3
	call	UCASE
	ld	(hl),a
	inc	hl
	inc	de
	djnz	getnam
gn2:	call	getfs
	jr	z,gn3
	inc	de
	jr	gn2
gn3:	ld	(hl),0
	ret

; Return Z if char in A is blank.

isblnk:	call	iseol
	ret	z
	cp	' '
	ret	z
	cp	TAB
	ret

; Return Z if char in A is EOL.

iseol:	or	a
	ret	z
	cp	CR
	ret	z
	cp	LF
	ret	z
	cp	ESC
	ret	z
	cp	1Ah
	ret

; Get next non-blank char. Returns Z flag set on end of line.

getns:	ld	a,(de)
	call	iseol
	ret	z
	call	isblnk
	ret	nz
	inc	de
	jr	getns

; Skip name.

skpnam:	ld	a,(de)
	call	iseol
	ret	z
	call	isblnk
	jr	z,getns		; return via getns
	inc	de
	jr	skpnam

; Get next char. Returns Z on end of line or if char is a delimiter.

getfs:	ld	a,(de)
	call	iseol
	ret	z
	cp	' '
	jr	c,gf1
	ret	z
	cp	'='
	ret	z
	cp	','
	ret	z
	cp	'/'
	ret
gf1:	xor	a
	ret

; Read a decimal number from input line into HL
; Returns CY if the number contains invalid chars or if overflow.

GETDEC:	ld	de,(lnptr)
	call	getns
	ld	hl,0
newdig:	call	getfs
	jr	z,endnum	; note no CY
	sub	'0'
	jr	c,endnum	; note CY
	cp	10
	ccf
	jr	c,endnum	; note CY
	call	adddig		; note CY on overflow
	inc	de
	jr	nc,newdig
endnum:	ld	(lnptr),de
	ret

adddig:	ld	c,l
	ld	b,h
	add	hl,hl
	ret	c
	add	hl,hl
	ret	c
	add	hl,bc
	ret	c
	add	hl,hl
	ret	c
	ld	c,a
	ld	b,0
	add	hl,bc
	ret

; Search for the command (cmdnam) in the command table (HL = cmdtab).
; Returns A=0FFh if not found, or 0 if cmdnam contains an empty string.
; Otherwise returns the command position in the table (1-based).

fndcmd:	ld	de,cmdnam
	ld	a,(de)
	or	a
	ret	z
	ld	b,0		; number of matches
	ld	c,1		; keyword index
	ld	a,c
	push	af
fcmd0:	ld	de,cmdnam
fcmd1:	ld	a,(de)
	or	a
	jr	z,fcmd3
	cp	(hl)
	jr	nz,fcmd2
	inc	hl
	inc	de
	jr	fcmd1
fcmd3:	inc	b
	pop	af
	ld	a,(hl)		;;
	or	a		;;
	ld	a,c
	ret	z		;;
	push	af
fcmd2:	ld	a,(hl)
	inc	hl
	or	a
	jr	nz,fcmd2
	inc	c
	ld	a,(hl)
	or	a
	jr	nz,fcmd0
	pop	af
	dec	b
	ret	z
	ld	a,0FFh
	ret

;-----------------------------------------------------------------------

; Add extension @DE to FDB @IX if none was originally specified.

addext:	ld	a,(ix+F.ATTR)
	and	FN.EXT		; extension present?
	ret	nz		; return if yes
	push	ix
	pop	hl
	ld	bc,F.EXT
	add	hl,bc		; point to extension field in FDB
	ex	de,hl
	ld	bc,3
	ldir			; copy extension
	ld	a,(ix+F.ATTR)
	or	FN.EXT		; set flag
	ld	(ix+F.ATTR),a
	ret

;-----------------------------------------------------------------------

doins:	xor	a
	ld	(runflg),a	; clear run flag
	ld	(remflg),a	; clear remove-on-exit flag
	ld	hl,(lnptr)
	ld	ix,fdb
	call	PFN		; get task file name into FDB
;;	ld	a,E.BADF
;;	ret	c
	ld	(lnptr),hl
	ld	de,tskext
	call	addext		; add TSK extension if necessary
	ld	a,(ix+F.ATTR)
	and	FN.NAME		; file name specified?
	jp	z,CMDERR	; error if not

	push	ix
	pop	hl
	ld	bc,F.NAME
	add	hl,bc
	ex	de,hl
	ld	hl,cmdbuf
	ld	b,9
cpnam:	ld	a,(de)
	cp	' '
	jr	z,done
	ld	(hl),a		; copy file name to command line buffer
	inc	hl
	inc	de
	djnz	cpnam
done:	ld	(hl),0
	ld	(cmdptr),hl

	xor	a
	ld	(newtsk+TD.NAME),a	; name defaults to task name
	ld	(newtsk+TD.PAR),a	; use partition from task header

	xor	a
	ld	(newtsk+TD.ATTR),a	; clear all attributes
	ld	(newtsk+TD.PRI),a	; no priority override
	ld	(newtsk+TD.USR),a	; default user number
	ld	(newtsk+TD.GRP),a	; default user group

	ld	de,(TSKTCB+T.CON)
	ld	a,(TSKTCB+T.CON+2)
	ld	(newtsk+TD.CON),de	; default console
	ld	(newtsk+TD.CON+2),a	;  is user's console

	ld	hl,0
	ld	(newtsk+TD.END),hl	; no increment by default
	ld	(newtsk+TD.SDAT),hl	; no data to send
	ld	(newtsk+TD.SLEN),hl

ckopt:	ld	de,(lnptr)	; check remainder of command line
	call	getns		; skip any spaces
	call	iseol		; end of command?
	jp	z,strtsk	; then install and possibly start task
	cp	'/'		; else check for option switch
	jp	nz,CMDERR	; error if not a switch
	inc	de		; skip switch delimiter
	ld	(lnptr),de	; save command pointer
	call	getcmd		; get switch name
	ld	hl,cmdnam
	ld	a,(hl)
	cp	' '		; null switch?
	jp	z,CMDERR	; not allowed
	ld	hl,optbl
	call	fndcmd		; else search for switch in option table
	or	a
	jp	z,CMDERR
	cp	0FFh
	jp	z,CMDERR	; error if no match
	ld	c,a		; save switch index in reg C
	dec	c
	jp	z,setrun	; set run flag
	call	chkeq		; '=' required for all except RUN
	jp	nz,CMDERR
	dec	c
	jp	z,defpar	; set task partition
	dec	c
	jp	z,defpri	; set task priority
	dec	c
	jp	z,defcon	; set task console
	dec	c
	jp	z,definc	; set increment
	dec	c
	jp	z,defnam	; set name
;	dec	c
;	jp	z,setcli
	dec	c
	jp	z,setacp
	dec	c
	jp	z,defcmd	; set command args, must be the last option
	jp	CMDERR

optbl:	db	'RUN',0
	db	'PAR',0
	db	'PRI',0
	db	'TERM',0
	db	'INC',0
	db	'TASK',0
;	db	'CLI',0
	db	'ACP',0
	db	'CMD',0
null:	db	0

argtbl:	db	'REM',0
	db	'YES',0
	db	0

; process RUN switch

setrun:	ld	a,1
	ld	(runflg),a
	ld	a,(TSKTCB+T.ATTR)
	and	1 SHL TA.MCR
	ld	c,a
	ld	a,(newtsk+TD.ATTR)
	or	c		; propagate TA.MCR attribute
	ld	(newtsk+TD.ATTR),a
	call	chkeq		; see if '='
	jp	nz,ckopt
	call	getcmd
	ld	hl,argtbl
	call	fndcmd
	dec	a		; only 'REM' accepted
	jp	nz,CMDERR
	ld	a,1
	ld	(remflg),a
	jp	ckopt

; process PRI switch

defpri:	call	GETDEC
	jp	c,CMDERR
	ld	a,h
	or	a
	jp	nz,CMDERR
	ld	a,l
	ld	(newtsk+TD.PRI),a ; task priority
	jp	ckopt

; process TERM switch

defcon:	call	PDN
	jp	c,CMDERR
	ld	(newtsk+TD.CON),de ; console device
	ld	a,c
	ld	(newtsk+TD.CON+2),a
	ld	(lnptr),hl
	jp	ckopt

; process INC switch

definc:	call	GETDEC
	jp	c,CMDERR
	ld	(newtsk+TD.END),hl
	jp	ckopt

; process TASK switch

defnam:	ex	de,hl
	ld	hl,newtsk+TD.NAME ; form task name
dn0:	ld	b,6
dn1:	call	getfs
	jr	z,dn2
;	cp	'.'
;	jr	z,dn2
	call	UCASE
	ld	(hl),a
	inc	hl
	inc	de
	djnz	dn1
	jr	dn3
dn2:	ld	(hl),' '
	inc	hl
	djnz	dn2
dn3:	ex	de,hl
	ld	(lnptr),hl
	jp	ckopt

; process PAR switch

defpar:	ex	de,hl
	ld	hl,newtsk+TD.PAR
	jr	dn0		; continue via common code

; process ACP switch

setacp:	call	getcmd
	ld	hl,argtbl
	call	fndcmd
	dec	a
	dec	a		; only 'YES' accepted
	jp	nz,CMDERR
	ld	a,(newtsk+T.ATTR)
	set	TA.ACP,a
	ld	(newtsk+TD.ATTR),a
	jp	ckopt

; process CMD option

defcmd:	ld	a,(runflg)	; CMD is illegal option without RUN
	or	a
	jp	z,CMDERR
	ex	de,hl
	ld	hl,(cmdptr)
	ld	(hl),' '
	inc	hl
	call	cpstr		; consumes everything until end of line
	ld	(hl),0
	ld	(cmdptr),hl
	ex	de,hl

	IF	0
dc0:	ld	a,(hl)
	or	a
	jr	z,dc1
	inc	hl		; skip everything until end of line
	jr	dc0
dc1:
	ENDIF

	ld	(lnptr),hl
	jp	ckopt

chkeq:	ld	hl,(lnptr)
	ld	a,(hl)
	cp	'='
	ret	nz
	inc	hl
	ld	(lnptr),hl
	ret

; finally, execute the specified action

strtsk:	ld	a,(runflg)
	or	a
	jr	nz,run
	ld	hl,newtsk
	call	INS		; install task
	jp	c,SYSERR
	ret

run:	ld	a,(remflg)
	or	a
	jr	z,run1
	ld	a,(newtsk+TD.ATTR)
	set	TA.REM,a	; set remove-on-exit attribute
	ld	(newtsk+TD.ATTR),a
run1:	ld	hl,newtsk
	call	INS		; sets/updates TD.NAME in newtsk
	jp	c,SYSERR
  IF 0
	ld	de,RQSTCB
	SC	.GTSK		; get installed task name
	jp	c,SYSERR
	ld	hl,RQSTCB+T.NAME
	ld	de,newtsk+TD.NAME
	ld	bc,6
	ldir			; set name field in TDB
  ENDIF
	ld	hl,cmdbuf
	call	setcml
	ld	hl,newtsk
	SC	.RPOI
	jp	c,SYSERR
	ret

tskext:	db	'TSK'

;-----------------------------------------------------------------------

; Setup task command line. HL = address of command tail.

setcml:	push	hl
	call	strlen
	ld	hl,0
	ld	(newtsk+TD.CMD),hl
	pop	hl
	ld	a,c
	or	a
	ret	z		; no command supplied
	ld	de,tskcml
	ld	(de),a
	inc	de
	ld	b,0
	ldir
	ld	hl,tskcml
	ld	(newtsk+TD.CMD),hl
	ret

strlen:	ld	c,0
strl1:	ld	a,(hl)
	or	a
	ret	z
	inc	hl
	inc	c
	jr	strl1

;-----------------------------------------------------------------------

; Install task (add it to the STD)
; Input:
;   Parsed filename in fdb buffer.
;   HL = addr of TDB to use to create task
;        Values used from user supplied TDB are:
;        - Task name
;        - Partition name
;        - Priority
;        - If TD.END is not zero, it's value will be used to increment
;          task size.
; Returns:
;   HL = new task TCB
;   CY set on error and error code in A.

KCALL	MACRO	addr
	call	SWSTK
	dw	addr
	ENDM

INS:	ld	(tdbadr),hl
	call	RDHDR		; read and validate task header
	ret	c		; on error return

	ld	a,(fdb+F.ATTR)
	and	FA.CTG		; contiguous file?
	ld	hl,(fdb+F.NUSED)
	jr	nz,fsz1
	ld	hl,(fdb+F.NALOC)
fsz1:	ld	a,h
	or	l
	ld	de,0
	jr	z,fsz2
	dec	hl		; since last block may not be full
	ld	d,l
	ld	l,h
	ld	h,0		; HLDE = nblocks * 256
	sla	d
	rl	l
	rl	h		; HLDE = nblocks * 512
	ld	bc,(fdb+F.LBCNT)
	ex	de,hl
	add	hl,bc		; HLDE += lbcnt
	ex	de,hl
	ld	bc,0
	adc	hl,bc		; HLDE = file size in bytes

fsz2:	ld	a,h
	or	l
	ld	a,E.PBIG
	scf
	ret	nz		; program too big

	ld	hl,-256
	add	hl,de		; subtract header size
	ld	a,E.BADTF
	ccf			; NC here means file too small
	ret	c
	ld	c,l
	ld	b,h

	ld	ix,(tdbadr)
	ld	l,(ix+TD.END)	; check for user INC option
	ld	h,(ix+TD.END+1)
	ld	a,h
	or	l
	jr	nz,useinc
	ld	hl,(hdr+TH.INC)
useinc:	add	hl,bc
	ld	a,E.PBIG
	ret	c		; increment too large
	ld	de,4095+100h	; (pagesize-1) for rounding + 100h page zero
	add	hl,de
	ret	c		; error if program extends beyond F000

	ld	a,h
	and	0F0h		; round to page size
	ld	h,a
	ld	l,0
	push	hl		; remember task top

	ld	a,(ix+TD.NAME)
	or	a		; user supplied a name?
	jr	z,dfnam
	cp	' '
	jr	nz,usenam	; use it if yes
dfnam:	push	ix
	pop	hl
	ld	de,TD.NAME
	add	hl,de
	ex	de,hl
	ld	hl,hdr+TH.NAME	; else use default task name from task header
	ld	bc,6
	ldir

usenam:	ld	a,(ix+TD.PAR)
	or	a		; user supplied a partition?
	jr	z,dfpar
	cp	' '
	jr	nz,usepar	; use it if yes
dfpar:	push	ix
	pop	hl
	ld	de,TD.PAR
	add	hl,de
	ex	de,hl
	ld	hl,hdr+TH.PAR	; else use default partition from task header
	ld	bc,6
	ldir

usepar:	push	ix
	pop	hl
	ld	de,TD.VID
	add	hl,de
	ex	de,hl
	ld	hl,hdr+TH.VID
	ld	bc,6
	ldir			; setup version identification

	ld	a,(ix+TD.PRI)
	or	a		; user supplied a priority value?
	jr	nz,usepri	; use it if yes
	ld	a,(hdr+TH.PRI)	; else set default priority from task header
	ld	(ix+TD.PRI),a

usepri:	res	TA.PRV,(ix+TD.ATTR) ; ignore user priv bit
	ld	a,(hdr+TH.PRV)
	or	a		; privileged task?
	jr	z,nopriv	; jump if not
	set	TA.PRV,(ix+TD.ATTR) ; else set priv bit in TDB

nopriv:	ld	hl,(fdb+F.DEV)
	ld	(ix+TD.LIB),l	; set load device
	ld	(ix+TD.LIB+1),h
	ld	a,(fdb+F.UNIT)
	ld	(ix+TD.LIB+2),a	; and unit

	ld	hl,(fdb+F.STABL)
	ld	(ix+TD.SBLK),l
	ld	(ix+TD.SBLK+1),h
	ld	(ix+TD.SBLK+2),0
	ld	(ix+TD.SBLK+3),0

	ld	hl,(fdb+F.NUSED)
	ld	(ix+TD.NBLK),l
	ld	(ix+TD.NBLK+1),h

	ld	hl,(hdr+TH.STRT)
	ld	(ix+TD.STR),l	; task space starts at 0000h
	ld	(ix+TD.STR+1),h
	ld	hl,100h
	ld	(ix+TD.EPT),l	; entry point is at 0100h
	ld	(ix+TD.EPT+1),h
	pop	hl		; pop saved task top
	ld	(ix+TD.SP),l	; set stack to top of task memory
	ld	(ix+TD.SP+1),h
	dec	hl
	ld	(ix+TD.END),l	; set top of task space
	ld	(ix+TD.END+1),h

	call	CHKPRV		; user privileged?
	jr	nc,upriv	; branch if yes

	bit	TA.REM,(ix+TD.ATTR) ; remove-on-exit task?
	scf
	ret	z		    ; return E.PRIV if not
	bit	TA.PRV,(ix+TD.ATTR) ; installing privileged task?
	scf
	ret	nz		    ; return E.PRIV if yes
	ld	(ix+TD.PRI),50	    ; limit priority to 50

upriv:	ld	c,1
	SC	.SUPER
	ret	c
	ld	hl,(tdbadr)
	KCALL	INSTSK		; enter the task into the STD
	push	af
	push	hl
	ld	c,0
	SC	.SUPER
	pop	hl		; return new task TCB in HL
	pop	af		;  and any error code in A
	ret

; Open task image file, read and validate header.
;
; Input:
;   Parsed filename in fdb buffer.
; Returns:
;   CY set on error and error code in A.

RDHDR:	ld	b,1		; LUN in B
	ld	de,(fdb+F.DEV)
	ld	a,(fdb+F.UNIT)
	ld	c,a		; device name in DE-C
	SC	.ALUN		; assign LUN
	ret	c

	ld	l,IO.ACC
	ld	h,SF.ACR OR SF.SHR
	ld	(qio1+Q.FUNC),hl
	ld	hl,qio1
	SC	.QIO		; open task image file
	ret	c		; on error return
	ld	a,(iosb)
	or	a
	scf
	ret	nz

	ld	hl,IO.RAT
	ld	(qio1+Q.FUNC),hl
	ld	hl,qio1
	SC	.QIO		; get file info
	jr	c,rderr		; on error close file and return
	ld	a,(iosb)
	or	a
	scf
	jr	nz,rderr

	ld	a,(fdb+F.ATTR)	; check file atrributes
	and	FA.CTG		; contiguous?
	ld	a,E.FNC		; error if not
	scf
	jr	z,rderr

	ld	hl,qio2		; read first block (task header)
	SC	.QIO		;  note: partial block read!
	jr	c,rderr
	ld	a,(iosb)
	or	a
	jr	c,rderr		; on error close file and return
	ld	hl,(iosb+2)
	ld	a,h		; read size must be 256 (0100h)
	dec	a
	or	l
	ld	a,E.BADTH
	scf
	jr	nz,rderr	; otherwise return error

	call	CHKHDR		; verify task header

rderr:	push	af
	ld	hl,IO.DEA
	ld	(qio1+Q.FUNC),hl
	ld	hl,qio1
	SC	.QIO		; close task image file
	pop	af
	ret

; Validate task header. Right now it simply checks signature and
; version number.

CHKHDR:	ld	hl,hdr
	ld	de,thid
	ld	b,6
ckhdr:	ld	a,(de)		; check task header ID
	cp	(hl)
	ld	a,E.BADTH
	scf
	ret	nz		; return CY if header is invalid
	inc	hl
	inc	de
	djnz	ckhdr
	ld	hl,(hdr+TH.VER)
	ld	de,0102h	; 1.2
	or	a
	sbc	hl,de
	ret	z
	scf
	ret

thid:	db	'TSK180'

; Check if user is privileged. Return with CY set and error code in A
; if not.

CHKPRV:	ld	hl,lcbbuf
	ld	c,I.USCB
	SC	.GIN
	ret	c
	ld	hl,lcbbuf+L.ST
	ld	a,E.PRIV
	bit	LS.PRV,(hl)
	scf
	ret	z
	xor	a
	ret

;-----------------------------------------------------------------------

	dseg

TSKTCB:	ds	TCBSZ		; our TCB

  IF 0
RQSTCB:	ds	TCBSZ		; requested task TCB
  ENDIF

lnptr:	ds	2
cmdnam:	ds	9

newtsk:	ds	TDBSZ		; task descriptor for new task (RUN)
cmdptr:	ds	2		; ptr to command args (RUN command)
runflg:	ds	1
remflg:	ds	1

cmdbuf:	ds	256

tskcml:	ds	130

qio1:	QIOW$	IO.ACC,1,9,iosb,<fdb,FINFSZ>	; for IO.ACC, IO.RAT & IO.DEA
qio2:	QIOW$	IO.RVB,1,9,iosb,<hdr,256,0,0,0>
iosb:	ds	4

fdb:	ds	FINFSZ
tdbadr:	ds	2		; address of user-supplied TDB in user space

hdr:	ds	256		; buffer for task header
lcbbuf:	ds	LCBSZ

	ds	256		; stack space
stack	equ	$

	end	START
