;**********************************************************************;
;                                                                      ;
;   Console logging task for RSX180.                                   ;
;   Copyright (C) 2015-2019, Hector Peraza.                            ;
;                                                                      ;
;   This program is free software; you can redistribute it and/or      ;
;   modify it under the terms of the GNU General Public License as     ;
;   published by the Free Software Foundation; either version 2 of     ;
;   the License, or (at your option) any later version.                ;
;                                                                      ;
;   This program is distributed in the hope that it will be useful,    ;
;   but WITHOUT ANY WARRANTY; without even the implied warranty of     ;
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      ;
;   GNU General Public License for more details.                       ;
;                                                                      ;
;   You should have received a copy of the GNU General Public License  ;
;   along with this program; if not, write to the Free Software        ;
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.          ;
;                                                                      ;
;**********************************************************************;

	.Z80

	include	SYSFN.INC
	include	SYSCONF.INC
	include	SYSTEM.INC
	include	QIO.INC
	include	FCB.INC
	include	TCB.INC
	include	PCB.INC
	include	DCB.INC
	include	AST.INC
	include	FCSLIB.INC
	include	ERRORS.INC

CR	equ	0Dh
LF	equ	0Ah

ASTEFN	equ	10
TMOEFN	equ	11

	extrn	PERROR,PUTSTR,PUTCH,TTFLSH,BCD2BIN,CVTBH,EXIT
	extrn	FCREAT,FCLOSE,FPUTLN,FFLUSH

KCALL	MACRO	addr
	call	SWSTK
	dw	addr
	ENDM

;-----------------------------------------------------------------------

	cseg

START::	ld	sp,stack

	ld	c,1
	SC	.SUPER
	jp	c,fatal

	call	SETLOG
	jp	c,abort

	ld	bc,astsrv
	ld	de,astbuf
	SC	.ASTDF		; setup AST service routine
	jp	c,fatal

	ld	e,AST.RD OR AST.CK
	ld	d,1		; enable data-received and mark-time ASTs
	SC	.ASTCT
	jp	c,fatal

	; create new log file

	ld	ix,logf
	ld	de,0
	ld	c,0
	call	FCREAT
	jp	c,fatal

	; write initial datestamp

	ld	hl,dtbuf
	SC	.GDAT
	jp	c,fatal

	ld	a,(dtbuf+3)
	ld	(today),a
	call	wrdat

loop:	; get packet

	ld	e,ASTEFN
	SC	.CLRFL
	ld	hl,rcvbuf
	ld	de,QDBSZ+2
	SC	.RECV		; receive data
	jr	c,wait
	ld	a,h
	or	l
	jr	z,wait

	; process packet

	ld	hl,rcvbuf
	call	propkt		; process packet
	jr	loop

wait:	; wait for message or timeout

	ld	hl,0
	ld	de,60*TCKSEC
	ld	c,TMOEFN	; unused, the AST routine will set ASTEFN
	SC	.MRKT		; 1-minute timeout
	ld	e,ASTEFN
	SC	.WTFLG		; wait for data or timeout
	ld	c,0FFh
	SC	.CMKT		; cancel mark-time request, if outstanding
	call	chkdat
	jr	loop

fatal:	call	SYSERR
abort:	call	UNSETL
	ld	hl,EX.SEV
	jr	quit

finish:	ld	hl,EX.SUC
quit:	push	hl
	ld	ix,logf
	call	FCLOSE
	call	UNSETL
	pop	hl
	jp	EXIT

;-----------------------------------------------------------------------

; Process MCR command

procmd:
	ret

onoff:	db	'ON',0
	db	'OFF',0
	db	0

optbl:	db	'COTERM',0
	db	'LOGFILE',0
	db	0

cotms1:	db	CR,LF,'Console = ',0
cotms2:	db	CR,LF,'Logfile = ',0
cotms3:	db	'Not logging on a terminal or to a file, exiting',0
cotms4:	db	'Console logging has not been turned on',0
mmsg:	db	'None',0

;-----------------------------------------------------------------------

; Process packet

propkt:	ld	a,(QDB+Q.FUNC)
	cp	IO.WLB
	ld	a,E.INV
	jr	nz,fnsto

;;	ld	de,(QDB+Q.BUF)
;;	ld	bc,(QDB+Q.LEN)
;;	call	VALBUF		; validate buffer
;;	ld	a,E.INV
;;	jr	c,fnsto

	ld	bc,(QDB+Q.LEN)	; BC = len
	call	trmlen		; trim length if necessary
	push	bc
	ld	hl,(QDB+Q.BUF)	; HL = src
	ld	de,tmpbuf	; DE = dst

	call	getbnk
	di
	exx
	ld	hl,($CPCB)
	ld	de,P.BASE
	add	hl,de
	ld	d,(hl)		; D' = dst bank
	ld	e,a		; E' = src babk
	exx
	call	$MCOPY		; copy data from user space
	ei

	ld	hl,tmpbuf
	pop	bc
	add	hl,bc
	ld	(hl),0		; add trailing zero
	call	trim		; remove trailing CR/LF, if present
	ld	de,tmpbuf
	call	wrmsg		; write timestamped message to file

fnsto:	ld	c,a
	ld	b,0
	push	bc
	ld	bc,(USRTSK)
	KCALL	$FNTCB		; get TCB of user task into IX
	pop	bc
	ret	c
	call	getbnk
	ld	e,a		; get bank of user task into reg E
	ld	hl,(QDB+Q.IOSB)	; get address in user space to store result
	di
	call	UPUTWB		; store result code
	ei
fnend:	ld	a,(QDB+Q.EFN)
	ld	e,a		; get event flag number into reg E
	ld	bc,(USRTSK)
	ld	hl,T.IOC
	add	hl,bc
	dec	(hl)		; decrement outstanding I/O count
	KCALL	SETFLG		; set event flag and resume task
	ret

; Get bank of user task

getbnk:	ld	ix,(USRTSK)
	push	hl
	push	de
	ld	l,(ix+T.PCB)
	ld	h,(ix+T.PCB+1)
	ld	de,P.BASE
	add	hl,de
	ld	a,(hl)
	pop	de
	pop	hl
	ret

; Trim message length

trmlen:	ld	a,b
	or	a
	jr	nz,tr1
	ld	a,c
	cp	100
	ret	c
tr1:	ld	bc,100-1
	ret

; Remove any trailing CR/LFs from message

trim:	ld	a,b
	or	c
	jr	z,trm1
	dec	hl
	dec	bc
	ld	a,(hl)
	cp	CR
	jr	z,trim
	cp	LF
	jr	z,trim
	inc	hl
trm1:	ld	(hl),0
	ret

; Add timestamp to message and output it to log file

wrmsg:	push	de
	call	chkdat		; get current date and time, and update
	pop	de		;  datestamp if necessary
	ret	c
wrmsg1:	ld	hl,msgbuf
	ld	a,(dtbuf+4)	; hour
	call	CVTBH
	ld	(hl),':'
	inc	hl
	ld	a,(dtbuf+5)	; min
	call	CVTBH
	ld	(hl),':'
	inc	hl
	ld	a,(dtbuf+6)	; sec
	call	CVTBH
	ld	(hl),' '
	inc	hl
	ld	(hl),' '
	inc	hl
	call	strcpy		; copy message string (address still in DE)
	ld	ix,logf
	ld	hl,msgbuf
	call	FPUTLN		; write message to log file
	call	FFLUSH
	ret

; Check current date, and write new datestamp if changed

chkdat:	ld	hl,dtbuf
	SC	.GDAT
	ret	c

	ld	hl,today
	ld	a,(dtbuf+3)	; get day
	cp	(hl)		; same?
	ret	z		; return if yes
	ld	(hl),a

	; date changed, write new datestamp

wrdat:	ld	hl,datbuf
	ld	de,eprfx+2
	call	strcpy
	ld	de,dtmsg
	call	strcpy
	ld	a,(dtbuf+3)	; day
	call	CVTBH
	ld	a,(dtbuf+2)	; month
	call	BCD2BIN
	dec	a
	ld	c,a
	add	a,a		; *2
	add	a,a		; *4
	ex	de,hl
	ld	hl,months
	ld	c,a
	ld	b,0
	add	hl,bc
	ld	bc,5
	ldir
	ex	de,hl
	ld	a,(dtbuf)	; year
	call	CVTBH
	ld	a,(dtbuf+1)
	call	CVTBH
	ld	(hl),0
	ld	de,datbuf
	call	wrmsg1		; write datestamp to log file
	xor	a
	ret

dtmsg:	db	'Date is ',0
months:	db	'-Jan-Feb-Mar-Apr-May-Jun-Jul-Aug-Sep-Oct-Nov-Dec-'

; AST service routine

astsrv:	push	af
	push	hl
	push	de
	push	bc
	ld	e,ASTEFN
	SC	.SETFL		; set event flag
	pop	bc
	pop	de
	pop	hl
	pop	af
	SC	.ASTX		; return to program

; Setup U.ACP of console driver.

SETLOG:	ld	de,'CO'
	ld	c,0
	ld	ix,($CTCB)
	set	TA.ACP,(ix+T.ATTR) ; just in case...
	KCALL	$FNDEV		; get UCB of console device
	jp	c,SYSERR

	push	hl
	pop	ix
	ld	a,(ix+U.UNIT)
	or	a
	jr	nz,s1		; ensure it is really CO0:
	ld	de,U.DCB
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	de,D.NAME
	add	hl,de
	ld	a,(hl)
	cp	'C'
	jr	nz,s1
	inc	hl
	ld	a,(hl)
	cp	'O'
	jr	z,s2
s1:	ld	hl,emsg1
	jp	ERROR

s2:	ld	a,(ix+U.ACP)
	or	(ix+U.ACP+1)	; U.ACP already set?
	ld	hl,emsg2
	jp	nz,ERROR
	ld	hl,($CTCB)
	ld	(ix+U.ACP),l
	ld	(ix+U.ACP+1),h
	ret

emsg1:	db	'CO: is redirected',0
emsg2:	db	'Console logger already active on CO:',0

UNSETL:	ld	de,'CO'
	ld	c,0
	ld	ix,($CTCB)
	KCALL	$FNDEV		; get UCB of console device
	ret	c

	push	hl
	pop	ix
	ld	a,(ix+U.UNIT)
	or	a
	scf
	ret	nz		; ensure it is really CO0:
	ld	de,U.DCB
	add	hl,de
	ld	de,D.NAME
	add	hl,de
	ld	a,(hl)
	cp	'C'
	scf
	ret	nz
	inc	hl
	ld	a,(hl)
	cp	'O'
	scf
	ret	nz
	xor	a
	ld	(ix+U.ACP),a	; clear U.ACP
	ld	(ix+U.ACP+1),a
	ret

;-----------------------------------------------------------------------

ERROR:	push	hl
	ld	hl,eprfx
	call	PUTSTR
	pop	hl
	call	PUTSTR
	ld	c,CR
	call	PUTCH
	scf
	ret

SYSERR:	push	af
	ld	hl,eprfx
	call	PUTSTR
	pop	af
	call	PERROR
	ld	c,CR
	call	PUTCH
	scf
	ret

eprfx:	db	CR,LF,'COT -- ',0

; Copy null-terminated string from (DE) to (HL)

strcpy:	ld	a,(de)
	ld	(hl),a
	or	a
	ret	z
	inc	hl
	inc	de
	jr	strcpy

;-----------------------------------------------------------------------

	dseg

rcvbuf:	equ	$		;  receive buffer
usrtsk:	ds	2		; !    do not    !
qdb:	ds	QDBSZ		; ! change order !

tmpbuf:	ds	100

msgbuf:	ds	128		; message buffer with timestamp
datbuf:	ds	32		; buffer for datestamp
dtbuf:	ds	8		; buffer for .GDAT
today:	ds	1
astbuf:	ds	5		; buffer for AST routine (unused, but required)

logfdb:	defw	0
	defb	FN.DEV OR FN.DIR OR FN.NAME OR FN.EXT
	defb	'LB',0
	defb	'SYSLOG   '
	defb	'CONSOLE  ','LOG'
	defw	0
	defs	FINFSZ-($-logfdb)

logf:	FSR$	logfdb,<1 SHL FM.WR>,1,9

	ds	256		; stack space
stack	equ	$

	end	START
